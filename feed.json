{
    "version": "https://jsonfeed.org/version/1",
    "title": "一个真正的鳗",
    "subtitle": "真正的鳗",
    "icon": "https://lktwh.github.io/images/favicon.ico",
    "description": "真正的鳗",
    "home_page_url": "https://lktwh.github.io",
    "items": [
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/C++/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/C++/",
            "title": "C++",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"函数\"><a class=\"anchor\" href=\"#函数\">#</a> 函数</h1>\n<blockquote>\n<p><strong>实际参数</strong>和<strong>形式参数</strong></p>\n<p>实际参数是出现在函数调用时圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。</p>\n</blockquote>\n<blockquote>\n<p><strong>函数原型</strong></p>\n<p>函数头以分号结尾，就构成了函数原型，目的是告诉编译器函数长什么样子。</p>\n</blockquote>\n<blockquote>\n<p><strong>类型不匹配</strong></p>\n<p>调用函数时给的参数值与参数的类型不匹配，但是编译器会将类型转换好，很可能不是自己所想要的。</p>\n</blockquote>\n<blockquote>\n<p>C 语言在调用函数时，永远只能传值给函数。</p>\n</blockquote>\n<blockquote>\n<p><strong>本地（局部）变量</strong></p>\n<ul>\n<li>定义在块内的\n<ul>\n<li>定义在函数块内</li>\n<li>定义在语句块内</li>\n<li>也可以是随便拉一对大括号来定义变量</li>\n</ul>\n</li>\n<li>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了</li>\n<li>块外面定义的变量在块里面仍然有效</li>\n<li>块里面定义了和块外面同名的变量则覆盖了外面的</li>\n<li>不能在一个块内定义同名的变量</li>\n<li>本地变量不会被默认初始化</li>\n<li>参数在进入函数的时候就被初始化了</li>\n<li><strong>返回本地变量的地址是危险的</strong>，因为本地变量是存放在栈区的，栈区的变量在函数结束时会自动释放。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>全局变量</strong></p>\n<ul>\n<li>定义在函数外面的变量是全局变量</li>\n<li>全局变量有全局的生存期和作用域\n<ul>\n<li>它们与任何函数都无关</li>\n<li>在任何函数内部都可以使用它们</li>\n</ul>\n</li>\n<li>没有做初始化的全局变量会得到 0 值，本地变量不会\n<ul>\n<li>指针会得到 NULL</li>\n</ul>\n</li>\n<li>只能用编译时刻已知的值为全局变量进行初始化</li>\n<li>它们的初始化发生在 main 函数之前</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>静态本地变量</strong></p>\n<ul>\n<li>在本地变量定义时加上 static 修饰符就可以成为静态本地变量</li>\n<li>当函数离开时，静态本地变量会继续保持其值</li>\n<li>静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值</li>\n<li>静态本地变量实际上是特殊的全局变量</li>\n<li>它们位于相同的内存区域</li>\n<li>静态本地变量具有全局的生存期和函数内部的作用域</li>\n</ul>\n</blockquote>\n<ul>\n<li>不要使用全局变量来在函数间传递参数结果</li>\n<li>尽量避免使用全局变量</li>\n<li>使用全局变量和静态本地变量是线程不安全的</li>\n</ul>\n<h3 id=\"函数的一些高级特性\"><a class=\"anchor\" href=\"#函数的一些高级特性\">#</a> 函数的一些高级特性</h3>\n<h4 id=\"函数的默认参数\"><a class=\"anchor\" href=\"#函数的默认参数\">#</a> 函数的默认参数</h4>\n<p>在 C++ 中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法： <code>返回值类型 函数名(参数 = 默认值) &#123;&#125;</code></p>\n<p>注意事项：</p>\n<ol>\n<li>如果某个位置已经有了默认参数，那么从这个参数以后，都必须有默认值；</li>\n<li>函数的声明和实现只能由一个写默认参数</li>\n</ol>\n<h4 id=\"函数的重载\"><a class=\"anchor\" href=\"#函数的重载\">#</a> 函数的重载</h4>\n<p>意义：函数名可以相同，提高复用性</p>\n<p><strong>函数重载需要满足的条件：</strong></p>\n<ul>\n<li>同一个作用域下</li>\n<li>函数名相同</li>\n<li>函数参数类型不同或者个数不同或者顺序不同</li>\n<li><strong>函数的返回值不能作为函数重载的条件</strong></li>\n</ul>\n<p><strong>函数重载的注意事项：</strong></p>\n<ol>\n<li>\n<p>引用作为函数重载的条件</p>\n<figure class=\"highlight c\"><figcaption><span>函数注意事项</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;func(int &amp;a) 调用&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> &amp;a)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;func(const int &amp;a) 调用&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// int &amp;a = 10; 这句话是错误的，因为引用必须引用合法的内存空间，所以这句话是错误的</span></span><br><span class=\"line\">\t<span class=\"comment\">// 那么我们想要调用上面这两个函数，方法如下：</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> &amp;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\tfunc(a);</span><br><span class=\"line\">\tfunc(<span class=\"number\">10</span>); <span class=\"comment\">// const int &amp;a = 10;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数重载碰到函数的默认参数</p>\n</li>\n</ol>\n<h1 id=\"数组和指针\"><a class=\"anchor\" href=\"#数组和指针\">#</a> 数组和指针</h1>\n<h2 id=\"数组\"><a class=\"anchor\" href=\"#数组\">#</a> 数组</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如何得到数组的长度呢？ （sizeof）</span></span><br><span class=\"line\"><span class=\"type\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> length = <span class=\"keyword\">sizeof</span>(a) / <span class=\"keyword\">sizeof</span>(a[<span class=\"number\">0</span>]); </span><br></pre></td></tr></table></figure>\n<h3 id=\"定义数组\"><a class=\"anchor\" href=\"#定义数组\">#</a> 定义数组</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C99 之前：元素的数量必须是编译时刻确定的字面量</span></span><br><span class=\"line\">type arrayName[ arraySize ]; <span class=\"comment\">//这样定义的数组未初始化</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>数组作为函数的参数时，往往需要另一个参数来传入数组的大小</p>\n</blockquote>\n<h3 id=\"二维数组\"><a class=\"anchor\" href=\"#二维数组\">#</a> 二维数组</h3>\n<p>定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrayName[row][col]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>列数是必须给出的，行数可以由编译器来数</li>\n<li>每行一个 {} ，使用逗号分隔</li>\n</ul>\n</blockquote>\n<h2 id=\"取地址运算\"><a class=\"anchor\" href=\"#取地址运算\">#</a> 取地址运算：&amp;</h2>\n<ul>\n<li>&amp;：获取变量的地址，操作数必须是一个变量</li>\n<li>地址的大小是否与 int 相同取决于编译器\n<ul>\n<li>\n<pre><code class=\"language-C\">int main() &#123;\n\n    int a = 0;\n\n    printf(&quot;%lu\\n&quot;, sizeof(int));\n    printf(&quot;%lu\\n&quot;, sizeof(&amp;a));\n\n&#125;\n// 在 64 位架构下，得到的结果是：4   8\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 指针</span><br><span class=\"line\"></span><br><span class=\"line\">- 指针变量就是保存地址的变量</span><br><span class=\"line\">  - `int *p = &amp;i`</span><br><span class=\"line\">- 变量的值是内存的地址</span><br><span class=\"line\">  - 普通变量的值是实际的值</span><br><span class=\"line\">  - 指针变量的值是具有实际值的变量的地址</span><br><span class=\"line\"></span><br><span class=\"line\">#### 作为参数的指针</span><br><span class=\"line\"></span><br><span class=\"line\">```C</span><br><span class=\"line\">#include &quot;stdio.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">void f(int *p);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int a = 0;</span><br><span class=\"line\">    printf(&quot;&amp;a=%p\\n&quot;, &amp;a);</span><br><span class=\"line\">    f(&amp;a);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f(int *p) &#123;</span><br><span class=\"line\">    printf(&quot; p=%p\\n&quot;, p);</span><br><span class=\"line\">    printf(&quot;*p=%d\\n&quot;, *p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">&amp;a=00000009087ffc3c</span><br><span class=\"line\"> p=00000009087ffc3c</span><br><span class=\"line\">*p=0</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"访问那个地址上的变量\"><a class=\"anchor\" href=\"#访问那个地址上的变量\">#</a> 访问那个地址上的变量</h4>\n<ul>\n<li>* 是一个单目运算符，用来访问指针的值所表示的地址上的变量</li>\n<li>可以作左值，也可以作右值\n<ul>\n<li>\n<pre><code class=\"language-C\">int k = *p;\n*p = k + 1;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 指针应用</span><br><span class=\"line\"></span><br><span class=\"line\">- 函数返回多个值，某些值只能通过指针返回</span><br><span class=\"line\"></span><br><span class=\"line\">#### 指针与数组</span><br><span class=\"line\"></span><br><span class=\"line\">传入函数的数组成了什么？</span><br><span class=\"line\"></span><br><span class=\"line\">- 函数参数表中的数组实际上是指针</span><br><span class=\"line\">  - sizeof(a) == sizeof(int *)</span><br><span class=\"line\">  - 但是可以使用数组的运算符 [] 进行运算</span><br><span class=\"line\"></span><br><span class=\"line\">##### 数组变量是特殊的指针</span><br><span class=\"line\"></span><br><span class=\"line\">- 数组变量本身表达地址，因此</span><br><span class=\"line\">  - int a[10]; int *p = a; //不需要 &amp; </span><br><span class=\"line\">  - 但是数组的单元表达的是变量 需要使用 &amp; 取地址</span><br><span class=\"line\">  - a == &amp;a[0]</span><br><span class=\"line\">-  [] 运算符可以对数组做，也可以对指针做</span><br><span class=\"line\">  - p[0] &lt;==&gt; a[0]</span><br><span class=\"line\">- \\* 运算符可以对指针做，也可以对数组做</span><br><span class=\"line\">  - *a &lt;==&gt; a[0]</span><br><span class=\"line\">- 数组变量是 const 指针，所以不能被赋值，即</span><br><span class=\"line\">  - int a[] &lt;==&gt; int * const a</span><br><span class=\"line\">  - 因此，int b[]; b = a 是错误的</span><br><span class=\"line\">  - 但是可以写成 int *q = a;</span><br><span class=\"line\"></span><br><span class=\"line\">#### 指针与 const</span><br><span class=\"line\"></span><br><span class=\"line\">##### 指针是 const（指针常量）</span><br><span class=\"line\"></span><br><span class=\"line\">- 表示一旦得到某个变量的地址，就不能再指向其他的变量</span><br><span class=\"line\"></span><br><span class=\"line\">```C</span><br><span class=\"line\">int * const q = &amp;i; // q 是 const</span><br><span class=\"line\">*q = 22; // OK</span><br><span class=\"line\">q++;  // ERROR</span><br><span class=\"line\">q = &amp;j;  // ERROR </span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"所指的是-const常量指针\"><a class=\"anchor\" href=\"#所指的是-const常量指针\">#</a> 所指的是 const（常量指针）</h5>\n<ul>\n<li>表示不能通过指针去修改那个变量（指针的指向可以修改，但是指针指向的值不能修改）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *p = &amp;i;</span><br><span class=\"line\">*p = <span class=\"number\">26</span>; <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">i = <span class=\"number\">26</span>;  <span class=\"comment\">// OK</span></span><br><span class=\"line\">p = &amp;j; <span class=\"comment\">// OK </span></span><br></pre></td></tr></table></figure>\n<h5 id=\"保护数组的值\"><a class=\"anchor\" href=\"#保护数组的值\">#</a> 保护数组的值</h5>\n<ul>\n<li>因为把数组传入函数时传递的是地址，所以函数内部可以修改数组的值</li>\n<li>为了保护数组的值不被函数破坏，可以将参数设置为 const</li>\n<li>int sum(const int a[], int length);</li>\n</ul>\n<h4 id=\"空指针与野指针\"><a class=\"anchor\" href=\"#空指针与野指针\">#</a> 空指针与野指针</h4>\n<h5 id=\"空指针\"><a class=\"anchor\" href=\"#空指针\">#</a> 空指针</h5>\n<ul>\n<li>空指针用于给指针变量进行初始化： <code>int *p = NULL</code></li>\n<li>空指针是不能进行访问的，即 <code>*p = 100</code>  是不允许的</li>\n</ul>\n<h5 id=\"野指针\"><a class=\"anchor\" href=\"#野指针\">#</a> 野指针</h5>\n<h4 id=\"指针运算\"><a class=\"anchor\" href=\"#指针运算\">#</a> 指针运算</h4>\n<p>*(p + n) &lt;==&gt; a[n]</p>\n<p>*p++  （优先级）</p>\n<h1 id=\"结构类型-宏\"><a class=\"anchor\" href=\"#结构类型-宏\">#</a> 结构类型、宏</h1>\n<h3 id=\"结构类型\"><a class=\"anchor\" href=\"#结构类型\">#</a> 结构类型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> month;</span><br><span class=\"line\">    <span class=\"type\">int</span> day;</span><br><span class=\"line\">    <span class=\"type\">int</span> year;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义变量（还有其他方法）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span>;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span> =</span> &#123;.month = <span class=\"number\">7</span>, .year = <span class=\"number\">2023</span>&#125;;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span> =</span> &#123;<span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">2023</span>&#125;; </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 访问成员</span></span><br><span class=\"line\"> today.month</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 结构指针</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> *<span class=\"title\">pDate</span> =</span> &amp;today;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指针所指的结构变量的成员</span></span><br><span class=\"line\">(*pDate).month = <span class=\"number\">12</span>;</span><br><span class=\"line\">pDate-&gt;month = <span class=\"number\">12</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义数据类型\"><a class=\"anchor\" href=\"#自定义数据类型\">#</a> 自定义数据类型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ADate</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> month;</span><br><span class=\"line\">    <span class=\"type\">int</span> day;</span><br><span class=\"line\">    <span class=\"type\">int</span> year;</span><br><span class=\"line\">&#125; Date;</span><br></pre></td></tr></table></figure>\n<h3 id=\"宏\"><a class=\"anchor\" href=\"#宏\">#</a> 宏</h3>\n<h4 id=\"编译预处理指令\"><a class=\"anchor\" href=\"#编译预处理指令\">#</a> 编译预处理指令</h4>\n<ul>\n<li>#开头的是编译预处理指令</li>\n<li>它们不是 C 语言的成分，但是 C 语言程序离不开它们</li>\n<li>#define 用来定义一个宏\n<ul>\n<li>\n<pre><code class=\"language-C\">// 结尾没有分号，因为不是 C 的语句\n#define PI 3.14159\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 如果一个宏的值中有其他宏的名字，也是会被替换的</span><br><span class=\"line\">- 如果一个宏的值超过一行，最后一行之前的行末需要加 \\</span><br><span class=\"line\">- 宏的值后面出现的注释不会被当作宏的一部分</span><br><span class=\"line\">- 宏可以带参数（像函数一样）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">------</span><br><span class=\"line\"></span><br><span class=\"line\">C语言包含哪些数据类型？</span><br><span class=\"line\"></span><br><span class=\"line\">1. 整数</span><br><span class=\"line\">   1. char：1 字节</span><br><span class=\"line\">   2. short：2 字节</span><br><span class=\"line\">   3. int：取决于编译器，通常的意义是“1 个字”</span><br><span class=\"line\">   4. long：取决于编译器</span><br><span class=\"line\">   5. long long：8 字节</span><br><span class=\"line\">2. 浮点数</span><br><span class=\"line\">   1. float</span><br><span class=\"line\">   2. double</span><br><span class=\"line\">   3. long double</span><br><span class=\"line\">3. 逻辑</span><br><span class=\"line\">   1. bool</span><br><span class=\"line\">4. 指针</span><br><span class=\"line\">5. 自定义类型</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; C语言提供了 sizeof（静态运算符） 来给出某个类型或者某个变量在内存中所占据的字节数</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; 整数在计算机中以补码的形式存在。比如 char 类型的变量 c = 255， 那么我们以整数的方式输出，得到的是 -1，如果想让该字符就是 255，那么可以加上 unsigned 关键字</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- 在使用和定义这个函数的地方都应该 #include 这个头文件（文本插入）</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; **声明和定义**</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; int i; 变量的定义</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; extern int i; 变量的声明（在头文件中）</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">&gt; - 声明是不产生代码的东西</span><br><span class=\"line\">&gt;   - 函数原型</span><br><span class=\"line\">&gt;   - 变量声明</span><br><span class=\"line\">&gt;   - 结构声明</span><br><span class=\"line\">&gt;   - 宏声明</span><br><span class=\"line\">&gt;   - 枚举声明</span><br><span class=\"line\">&gt;   - 类型声明</span><br><span class=\"line\">&gt;   - inline 函数</span><br><span class=\"line\">&gt; - 定义是产生代码的东西</span><br><span class=\"line\"></span><br><span class=\"line\"># C++ 核心编程</span><br><span class=\"line\"></span><br><span class=\"line\">## 内存分区模型</span><br><span class=\"line\"></span><br><span class=\"line\">C++ 程序在执行时，将内存大致分为四个区：</span><br><span class=\"line\"></span><br><span class=\"line\">- 代码区：存放函数体的二进制代码，由操作系统进行管理</span><br><span class=\"line\">- 全局区：存放全局变量、静态变量以及常量，常量只包含字符串常量以及 const 修饰的全局变量</span><br><span class=\"line\">- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</span><br><span class=\"line\">- 堆区：由程序员分配和释放，若没有手动释放，在程序结束后由操作系统回收</span><br><span class=\"line\"></span><br><span class=\"line\">## 引用</span><br><span class=\"line\"></span><br><span class=\"line\">**引用的作用**：给变量起别名</span><br><span class=\"line\"></span><br><span class=\"line\">语法：数据类型 &amp;别名 = 原名</span><br><span class=\"line\"></span><br><span class=\"line\">```c 引用</span><br><span class=\"line\">int a = 10;</span><br><span class=\"line\">int &amp;b = a;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>引用需要的注意事项：</p>\n<ol>\n<li>引用必须要初始化；即  <code>int &amp;b;</code>  是错误的；</li>\n<li>引用一旦初始化后，就不可以更改了。</li>\n</ol>\n<h3 id=\"引用做函数的参数\"><a class=\"anchor\" href=\"#引用做函数的参数\">#</a> 引用做函数的参数</h3>\n<p><strong>作用</strong>：函数传参时，可以利用引用技术让形参修饰实参</p>\n<figure class=\"highlight c\"><figcaption><span>引用做函数参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a, <span class=\"type\">int</span> &amp;b)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用作为函数的返回参数\"><a class=\"anchor\" href=\"#引用作为函数的返回参数\">#</a> 引用作为函数的返回参数</h3>\n<ol>\n<li>\n<p>不能返回局部变量的引用</p>\n</li>\n<li>\n<p>如果函数的返回值是引用，那么这个函数的调用可以作为左值</p>\n<figure class=\"highlight c\"><figcaption><span>引用做函数的返回值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp; <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> &amp;ref = test();</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttest() = <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">10</span></span><br><span class=\"line\"><span class=\"comment\">1000</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"引用的本质\"><a class=\"anchor\" href=\"#引用的本质\">#</a> 引用的本质</h3>\n<p>本质：引用的本质在 C++ 内部实现是一个指针常量</p>\n<figure class=\"highlight c\"><figcaption><span>引用的本质</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">   system(<span class=\"string\">&quot;chcp 65001&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 自动转换为 int * const ref = &amp;a; 指针常量的指向不可以修改，所以引用的指向不可以更改</span></span><br><span class=\"line\">   <span class=\"type\">int</span> &amp;ref = a;</span><br><span class=\"line\">   <span class=\"comment\">// 内部发现是引用，那么会转换为 *ref = 20</span></span><br><span class=\"line\">   ref = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类和对象\"><a class=\"anchor\" href=\"#类和对象\">#</a> 类和对象</h2>\n<h3 id=\"封装\"><a class=\"anchor\" href=\"#封装\">#</a> 封装</h3>\n<p>封装是三大特性之一</p>\n<p>封装的意义：</p>\n<ul>\n<li>将属性和行为作为一个整体，表现生活中的事务</li>\n<li>将属性和行为加以权限控制</li>\n</ul>\n<p>定义一个类的方法：</p>\n<figure class=\"highlight c\"><figcaption><span>类</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 &#123;</span></span><br><span class=\"line\">访问修饰符:</span><br><span class=\"line\">\t属性...</span><br><span class=\"line\">\t方法...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"访问权限\"><a class=\"anchor\" href=\"#访问权限\">#</a> 访问权限</h4>\n<ol>\n<li>public：公共权限，类内可以访问，类外可以访问</li>\n<li>protected：保护权限，类内可以访问，类外不能访问，子类可以访问父类保护的内容</li>\n<li>private：私有权限，类内可以访问，类外不能访问</li>\n</ol>\n<blockquote>\n<p><em><strong>但是，我们可以通过类中的 public 方法来修改和得到类中私有属性的值。</strong></em></p>\n</blockquote>\n<p><strong>在 C++ 中我们通常将成员变量设置为私有</strong></p>\n<ol>\n<li>将成员变量设置为私有，可以自己控制读写权限</li>\n<li>对于写权限，我们可以检测数据的有效性</li>\n</ol>\n<p>我们可以写 public 的 get 和 set 方法来实现属性的读写</p>\n<h4 id=\"class-和-struct-的区别\"><a class=\"anchor\" href=\"#class-和-struct-的区别\">#</a> class 和 struct 的区别</h4>\n<p>在 C++ 中 struct 和 class 的唯一区别就是在默认的访问权限不同</p>\n<ul>\n<li>struct 的默认访问权限是 public</li>\n<li>class 的默认访问权限是 private</li>\n</ul>\n<h3 id=\"对象特性\"><a class=\"anchor\" href=\"#对象特性\">#</a> 对象特性</h3>\n<h4 id=\"构造函数和析构函数\"><a class=\"anchor\" href=\"#构造函数和析构函数\">#</a> 构造函数和析构函数</h4>\n<p>在 C++ 中使用了构造函数和析构函数被编译器自动调用，完成对象的初始化和清理工作</p>\n<p>我们可以不提供构造和析构函数，编译器会提供，<strong>但是</strong>，编译器提供的构造函数和析构函数是空函数</p>\n<p><strong>构造函数</strong>： <code>类型()&#123;&#125;</code></p>\n<ol>\n<li>构造函数没有返回值</li>\n<li>函数名和类名相同</li>\n<li>构造函数可以有参数，因此可以重载</li>\n<li>程序在创建对象时会自动调用构造函数，无需手动调用，且只会调用一次</li>\n</ol>\n<p><strong>析构函数</strong>： <code>~类名()&#123;&#125;</code></p>\n<ol>\n<li>析构函数也没有返回值</li>\n<li>函数名和类名相同，在函数名前加上～</li>\n<li>析构函数不能有参数，因此不能发生函数重载</li>\n<li>程序在对象销毁前会自动调用析构函数，无需手动调用，且只调用一次</li>\n</ol>\n<p><strong>构造函数的分类：</strong></p>\n<ul>\n<li>按参数分：有参构造和无参构造</li>\n<li>按类型分：普通构造和拷贝构造</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造格式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person() &#123; <span class=\"comment\">// 无参构造</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person(<span class=\"type\">int</span> age) &#123; <span class=\"comment\">// 有参构造</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Person(<span class=\"type\">const</span> Person &amp;p) &#123; <span class=\"comment\">// 这里必须是 const 的对象的引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数的三种调用方式：</strong></p>\n<ol>\n<li>\n<p>括号法</p>\n<ul>\n<li><strong>调用默认构造函数时，不要加小括号</strong>（编译器会认为这是一个函数的声明）</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>括号法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1; \t\t<span class=\"comment\">// 调用默认构造函数（无参构造）</span></span><br><span class=\"line\">Person <span class=\"title function_\">p2</span><span class=\"params\">(<span class=\"number\">10</span>)</span>;  <span class=\"comment\">// 调用有参构造函数</span></span><br><span class=\"line\">Person <span class=\"title function_\">p3</span><span class=\"params\">(p2)</span>;  <span class=\"comment\">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>显示法</p>\n<figure class=\"highlight c\"><figcaption><span>显示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = Person(<span class=\"number\">10</span>);</span><br><span class=\"line\">Person p2 = Person(p1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Person (10); 这是匿名对象，当前行执行结束后，系统会立刻回收匿名对象</li>\n<li>不要利用拷贝构造函数初始化匿名对象，因为编译器会认为  <code>Person(p1);</code>  等价于  <code>Person p1;</code></li>\n</ul>\n</li>\n<li>\n<p>隐式转换法</p>\n<figure class=\"highlight c\"><figcaption><span>隐式转换法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = <span class=\"number\">10</span>; <span class=\"comment\">//有参</span></span><br><span class=\"line\">Person p2 = p1; <span class=\"comment\">//拷贝</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>拷贝构造函数的调用时机</strong></p>\n<ul>\n<li>\n<p>使用一个已经创建完的对象来初始化一个新的对象</p>\n</li>\n<li>\n<p>值传递的方式给函数传参数</p>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">doWork</span><span class=\"params\">(Person p)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tPerson <span class=\"title function_\">p1</span><span class=\"params\">(<span class=\"number\">10</span>)</span>;</span><br><span class=\"line\">\tdoWork(p1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当我们调用 test 函数时，会调用有参构造函数，然后调用拷贝构造函数，这就是在使用值传递的方式给函数传递参数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>以值方式返回局部对象</p>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造函数调用时机</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person <span class=\"title function_\">doWoek2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person p = doWork2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当我们调用 test 函数时，由于 doWork2 函数返回了对象，那么会调用一次拷贝构造函数</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>构造函数的一些规则</strong></p>\n<p>默认情况下，C++ 编译器至少给一个类添加三个函数</p>\n<ol>\n<li>默认构造函数（无参，函数体为空）</li>\n<li>默认析构函数（无参，函数体为空）</li>\n<li>默认拷贝函数，对属性进行值拷贝</li>\n</ol>\n<ul>\n<li>如果程序员提供了有参构造函数，编译器不会再提供无参的构造函数，但是会提供默认的拷贝构造函数</li>\n<li>如果程序员提供了拷贝构造函数，编译器不会再提供其他的构造函数</li>\n</ul>\n<h4 id=\"深拷贝与浅拷贝\"><a class=\"anchor\" href=\"#深拷贝与浅拷贝\">#</a> 深拷贝与浅拷贝</h4>\n<p><strong>浅拷贝</strong>：简单的赋值拷贝操作</p>\n<p>浅拷贝带来的问题就是<strong>堆区的重复释放</strong></p>\n<figure class=\"highlight c\"><figcaption><span>浅拷贝</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> p_age;</span><br><span class=\"line\">    <span class=\"type\">int</span> *p_height;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(<span class=\"type\">int</span> age, <span class=\"type\">int</span> height) &#123;</span><br><span class=\"line\">        p_age = age;</span><br><span class=\"line\">        p_height = new <span class=\"type\">int</span>(height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 析构代码，将堆区开辟的数据进行释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p_height != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            delete p_height;</span><br><span class=\"line\">            p_height = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person <span class=\"title function_\">p1</span><span class=\"params\">(<span class=\"number\">19</span>, <span class=\"number\">185</span>)</span>;</span><br><span class=\"line\">    Person <span class=\"title function_\">p2</span><span class=\"params\">(p1)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"/assets/C++/C++_1.png\" alt=\"\"></p>\n<p>为了解决上面出现的问题，我们需要使用深拷贝的方法进行解决。</p>\n<p><strong>深拷贝</strong>：在堆区重新申请空间，进行拷贝操作</p>\n<p>我们使用了深拷贝后，p1 和 p2 指向的是不同的堆区，但是存放的数据是一样的，这样就不会造成堆区内存重复释放的问题了。</p>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/",
            "title": "C++ 核心编程",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"c-核心编程\"><a class=\"anchor\" href=\"#c-核心编程\">#</a> C++ 核心编程</h1>\n<h2 id=\"内存分区模型\"><a class=\"anchor\" href=\"#内存分区模型\">#</a> 内存分区模型</h2>\n<p>C++ 程序在执行时，将内存大致分为四个区：</p>\n<ul>\n<li>代码区：存放函数体的二进制代码，由操作系统进行管理</li>\n<li>全局区：存放全局变量、静态变量以及常量，常量只包含字符串常量以及 const 修饰的全局变量</li>\n<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>\n<li>堆区：由程序员分配和释放，若没有手动释放，在程序结束后由操作系统回收</li>\n</ul>\n<h2 id=\"引用\"><a class=\"anchor\" href=\"#引用\">#</a> 引用</h2>\n<p><strong>引用的作用</strong>：给变量起别名</p>\n<p>语法：数据类型 &amp; 别名 = 原名</p>\n<figure class=\"highlight c\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>\n<p>引用需要的注意事项：</p>\n<ol>\n<li>引用必须要初始化；即  <code>int &amp;b;</code>  是错误的；</li>\n<li>引用一旦初始化后，就不可以更改了。</li>\n</ol>\n<h3 id=\"引用做函数的参数\"><a class=\"anchor\" href=\"#引用做函数的参数\">#</a> 引用做函数的参数</h3>\n<p><strong>作用</strong>：函数传参时，可以利用引用技术让形参修饰实参</p>\n<figure class=\"highlight c\"><figcaption><span>引用做函数参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a, <span class=\"type\">int</span> &amp;b)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用作为函数的返回参数\"><a class=\"anchor\" href=\"#引用作为函数的返回参数\">#</a> 引用作为函数的返回参数</h3>\n<ol>\n<li>\n<p>不能返回局部变量的引用</p>\n</li>\n<li>\n<p>如果函数的返回值是引用，那么这个函数的调用可以作为左值</p>\n<figure class=\"highlight c\"><figcaption><span>引用做函数的返回值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp; <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> &amp;ref = test();</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttest() = <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">10</span></span><br><span class=\"line\"><span class=\"comment\">1000</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"引用的本质\"><a class=\"anchor\" href=\"#引用的本质\">#</a> 引用的本质</h3>\n<p>本质：引用的本质在 C++ 内部实现是一个指针常量</p>\n<figure class=\"highlight c\"><figcaption><span>引用的本质</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">   system(<span class=\"string\">&quot;chcp 65001&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 自动转换为 int * const ref = &amp;a; 指针常量的指向不可以修改，所以引用的指向不可以更改</span></span><br><span class=\"line\">   <span class=\"type\">int</span> &amp;ref = a;</span><br><span class=\"line\">   <span class=\"comment\">// 内部发现是引用，那么会转换为 *ref = 20</span></span><br><span class=\"line\">   ref = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类和对象\"><a class=\"anchor\" href=\"#类和对象\">#</a> 类和对象</h2>\n<h3 id=\"封装\"><a class=\"anchor\" href=\"#封装\">#</a> 封装</h3>\n<p>封装是三大特性之一</p>\n<p>封装的意义：</p>\n<ul>\n<li>将属性和行为作为一个整体，表现生活中的事务</li>\n<li>将属性和行为加以权限控制</li>\n</ul>\n<p>定义一个类的方法：</p>\n<figure class=\"highlight c\"><figcaption><span>类</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 &#123;</span></span><br><span class=\"line\">访问修饰符:</span><br><span class=\"line\">\t属性...</span><br><span class=\"line\">\t方法...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"访问权限\"><a class=\"anchor\" href=\"#访问权限\">#</a> 访问权限</h4>\n<ol>\n<li>public：公共权限，类内可以访问，类外可以访问</li>\n<li>protected：保护权限，类内可以访问，类外不能访问，子类可以访问父类保护的内容</li>\n<li>private：私有权限，类内可以访问，类外不能访问</li>\n</ol>\n<blockquote>\n<p><em><strong>但是，我们可以通过类中的 public 方法来修改和得到类中私有属性的值。</strong></em></p>\n</blockquote>\n<p><strong>在 C++ 中我们通常将成员变量设置为私有</strong></p>\n<ol>\n<li>将成员变量设置为私有，可以自己控制读写权限</li>\n<li>对于写权限，我们可以检测数据的有效性</li>\n</ol>\n<p>我们可以写 public 的 get 和 set 方法来实现属性的读写</p>\n<h4 id=\"class-和-struct-的区别\"><a class=\"anchor\" href=\"#class-和-struct-的区别\">#</a> class 和 struct 的区别</h4>\n<p>在 C++ 中 struct 和 class 的唯一区别就是在默认的访问权限不同</p>\n<ul>\n<li>struct 的默认访问权限是 public</li>\n<li>class 的默认访问权限是 private</li>\n</ul>\n<h3 id=\"对象特性\"><a class=\"anchor\" href=\"#对象特性\">#</a> 对象特性</h3>\n<h4 id=\"构造函数和析构函数\"><a class=\"anchor\" href=\"#构造函数和析构函数\">#</a> 构造函数和析构函数</h4>\n<p>在 C++ 中使用了构造函数和析构函数被编译器自动调用，完成对象的初始化和清理工作</p>\n<p>我们可以不提供构造和析构函数，编译器会提供，<strong>但是</strong>，编译器提供的构造函数和析构函数是空函数</p>\n<p><strong>构造函数</strong>： <code>类型()&#123;&#125;</code></p>\n<ol>\n<li>构造函数没有返回值</li>\n<li>函数名和类名相同</li>\n<li>构造函数可以有参数，因此可以重载</li>\n<li>程序在创建对象时会自动调用构造函数，无需手动调用，且只会调用一次</li>\n</ol>\n<p><strong>析构函数</strong>： <code>~类名()&#123;&#125;</code></p>\n<ol>\n<li>析构函数也没有返回值</li>\n<li>函数名和类名相同，在函数名前加上～</li>\n<li>析构函数不能有参数，因此不能发生函数重载</li>\n<li>程序在对象销毁前会自动调用析构函数，无需手动调用，且只调用一次</li>\n</ol>\n<p><strong>构造函数的分类：</strong></p>\n<ul>\n<li>按参数分：有参构造和无参构造</li>\n<li>按类型分：普通构造和拷贝构造</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造格式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person() &#123; <span class=\"comment\">// 无参构造</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person(<span class=\"type\">int</span> age) &#123; <span class=\"comment\">// 有参构造</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Person(<span class=\"type\">const</span> Person &amp;p) &#123; <span class=\"comment\">// 这里必须是 const 的对象的引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数的三种调用方式：</strong></p>\n<ol>\n<li>\n<p>括号法</p>\n<ul>\n<li><strong>调用默认构造函数时，不要加小括号</strong>（编译器会认为这是一个函数的声明）</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>括号法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1; \t\t<span class=\"comment\">// 调用默认构造函数（无参构造）</span></span><br><span class=\"line\">Person <span class=\"title function_\">p2</span><span class=\"params\">(<span class=\"number\">10</span>)</span>;  <span class=\"comment\">// 调用有参构造函数</span></span><br><span class=\"line\">Person <span class=\"title function_\">p3</span><span class=\"params\">(p2)</span>;  <span class=\"comment\">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>显示法</p>\n<figure class=\"highlight c\"><figcaption><span>显示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = Person(<span class=\"number\">10</span>);</span><br><span class=\"line\">Person p2 = Person(p1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Person (10); 这是匿名对象，当前行执行结束后，系统会立刻回收匿名对象</li>\n<li>不要利用拷贝构造函数初始化匿名对象，因为编译器会认为  <code>Person(p1);</code>  等价于  <code>Person p1;</code></li>\n</ul>\n</li>\n<li>\n<p>隐式转换法</p>\n<figure class=\"highlight c\"><figcaption><span>隐式转换法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = <span class=\"number\">10</span>; <span class=\"comment\">//有参</span></span><br><span class=\"line\">Person p2 = p1; <span class=\"comment\">//拷贝</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>拷贝构造函数的调用时机</strong></p>\n<ul>\n<li>\n<p>使用一个已经创建完的对象来初始化一个新的对象</p>\n</li>\n<li>\n<p>值传递的方式给函数传参数</p>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">doWork</span><span class=\"params\">(Person p)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tPerson <span class=\"title function_\">p1</span><span class=\"params\">(<span class=\"number\">10</span>)</span>;</span><br><span class=\"line\">\tdoWork(p1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当我们调用 test 函数时，会调用有参构造函数，然后调用拷贝构造函数，这就是在使用值传递的方式给函数传递参数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>以值方式返回局部对象</p>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造函数调用时机</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person <span class=\"title function_\">doWoek2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person p = doWork2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当我们调用 test 函数时，由于 doWork2 函数返回了对象，那么会调用一次拷贝构造函数</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>构造函数的一些规则</strong></p>\n<p>默认情况下，C++ 编译器至少给一个类添加三个函数</p>\n<ol>\n<li>默认构造函数（无参，函数体为空）</li>\n<li>默认析构函数（无参，函数体为空）</li>\n<li>默认拷贝函数，对属性进行值拷贝</li>\n</ol>\n<ul>\n<li>如果程序员提供了有参构造函数，编译器不会再提供无参的构造函数，但是会提供默认的拷贝构造函数</li>\n<li>如果程序员提供了拷贝构造函数，编译器不会再提供其他的构造函数</li>\n</ul>\n<h4 id=\"深拷贝与浅拷贝\"><a class=\"anchor\" href=\"#深拷贝与浅拷贝\">#</a> 深拷贝与浅拷贝</h4>\n<p><strong>浅拷贝</strong>：简单的赋值拷贝操作</p>\n<p>浅拷贝带来的问题就是<strong>堆区的重复释放</strong></p>\n<figure class=\"highlight c\"><figcaption><span>浅拷贝</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> p_age;</span><br><span class=\"line\">    <span class=\"type\">int</span> *p_height;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(<span class=\"type\">int</span> age, <span class=\"type\">int</span> height) &#123;</span><br><span class=\"line\">        p_age = age;</span><br><span class=\"line\">        p_height = new <span class=\"type\">int</span>(height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 析构代码，将堆区开辟的数据进行释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p_height != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            delete p_height;</span><br><span class=\"line\">            p_height = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person <span class=\"title function_\">p1</span><span class=\"params\">(<span class=\"number\">19</span>, <span class=\"number\">185</span>)</span>;</span><br><span class=\"line\">    Person <span class=\"title function_\">p2</span><span class=\"params\">(p1)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"/assets/C++/C++_1.png\" alt=\"\"></p>\n<p>为了解决上面出现的问题，我们需要使用深拷贝的方法进行解决。</p>\n<p><strong>深拷贝</strong>：在堆区重新申请空间，进行拷贝操作</p>\n<p>我们使用了深拷贝后，p1 和 p2 指向的是不同的堆区，但是存放的数据是一样的，这样就不会造成堆区内存重复释放的问题了。</p>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/",
            "title": "数组与指针",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"数组和指针\"><a class=\"anchor\" href=\"#数组和指针\">#</a> 数组和指针</h1>\n<h2 id=\"数组\"><a class=\"anchor\" href=\"#数组\">#</a> 数组</h2>\n<figure class=\"highlight c\"><figcaption><span>数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如何得到数组的长度呢？ （sizeof）</span></span><br><span class=\"line\"><span class=\"type\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> length = <span class=\"keyword\">sizeof</span>(a) / <span class=\"keyword\">sizeof</span>(a[<span class=\"number\">0</span>]); </span><br></pre></td></tr></table></figure>\n<h3 id=\"定义数组\"><a class=\"anchor\" href=\"#定义数组\">#</a> 定义数组</h3>\n<figure class=\"highlight c\"><figcaption><span>数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C99 之前：元素的数量必须是编译时刻确定的字面量</span></span><br><span class=\"line\">type arrayName[ arraySize ]; <span class=\"comment\">//这样定义的数组未初始化</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>数组作为函数的参数时，往往需要另一个参数来传入数组的大小</p>\n</blockquote>\n<h3 id=\"二维数组\"><a class=\"anchor\" href=\"#二维数组\">#</a> 二维数组</h3>\n<p>定义</p>\n<figure class=\"highlight c\"><figcaption><span>二维数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrayName[row][col]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>列数是必须给出的，行数可以由编译器来数</li>\n<li>每行一个 {} ，使用逗号分隔</li>\n</ul>\n</blockquote>\n<h2 id=\"取地址运算\"><a class=\"anchor\" href=\"#取地址运算\">#</a> 取地址运算：&amp;</h2>\n<ul>\n<li>\n<p>&amp;：获取变量的地址，操作数必须是一个变量</p>\n</li>\n<li>\n<p>地址的大小是否与 int 相同取决于编译器</p>\n<figure class=\"highlight c\"><figcaption><span>取址运算符</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lu\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lu\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(&amp;a));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在 64 位架构下，得到的结果是：4   8</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"指针\"><a class=\"anchor\" href=\"#指针\">#</a> 指针</h2>\n<ul>\n<li>指针变量就是保存地址的变量\n<ul>\n<li><code>int *p = &amp;i</code></li>\n</ul>\n</li>\n<li>变量的值是内存的地址\n<ul>\n<li>普通变量的值是实际的值</li>\n<li>指针变量的值是具有实际值的变量的地址</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"作为参数的指针\"><a class=\"anchor\" href=\"#作为参数的指针\">#</a> 作为参数的指针</h4>\n<figure class=\"highlight c\"><figcaption><span>指针参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> *p)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&amp;a=%p\\n&quot;</span>, &amp;a);</span><br><span class=\"line\">    f(&amp;a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> *p)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; p=%p\\n&quot;</span>, p);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*p=%d\\n&quot;</span>, *p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">&amp;a=00000009087ffc3c</span></span><br><span class=\"line\"><span class=\"comment\"> p=00000009087ffc3c</span></span><br><span class=\"line\"><span class=\"comment\">*p=0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"访问那个地址上的变量\"><a class=\"anchor\" href=\"#访问那个地址上的变量\">#</a> 访问那个地址上的变量</h4>\n<ul>\n<li>\n<p>* 是一个单目运算符，用来访问指针的值所表示的地址上的变量</p>\n</li>\n<li>\n<p>可以作左值，也可以作右值</p>\n<figure class=\"highlight c\"><figcaption><span>*运算符</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> k = *p;</span><br><span class=\"line\">*p = k + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"指针应用\"><a class=\"anchor\" href=\"#指针应用\">#</a> 指针应用</h4>\n<ul>\n<li>函数返回多个值，某些值只能通过指针返回</li>\n</ul>\n<h4 id=\"指针与数组\"><a class=\"anchor\" href=\"#指针与数组\">#</a> 指针与数组</h4>\n<p>传入函数的数组成了什么？</p>\n<ul>\n<li>函数参数表中的数组实际上是指针\n<ul>\n<li>sizeof(a) == sizeof(int *)</li>\n<li>但是可以使用数组的运算符 [] 进行运算</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"数组变量是特殊的指针\"><a class=\"anchor\" href=\"#数组变量是特殊的指针\">#</a> 数组变量是特殊的指针</h5>\n<ul>\n<li>数组变量本身表达地址，因此\n<ul>\n<li>int a [10]; int *p = a; // 不需要 &amp;</li>\n<li>但是数组的单元表达的是变量 需要使用 &amp; 取地址</li>\n<li>a == &amp;a[0]</li>\n</ul>\n</li>\n<li>[] 运算符可以对数组做，也可以对指针做</li>\n<li>p[0] &lt;==&gt; a[0]</li>\n<li>* 运算符可以对指针做，也可以对数组做\n<ul>\n<li>*a &lt;==&gt; a[0]</li>\n</ul>\n</li>\n<li>数组变量是 const 指针，所以不能被赋值，即\n<ul>\n<li>int a[] &lt;==&gt; int * const a</li>\n<li>因此，int b []; b = a 是错误的</li>\n<li>但是可以写成 int *q = a;</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"指针与-const\"><a class=\"anchor\" href=\"#指针与-const\">#</a> 指针与 const</h4>\n<h5 id=\"指针是-const指针常量\"><a class=\"anchor\" href=\"#指针是-const指针常量\">#</a> 指针是 const（指针常量）</h5>\n<ul>\n<li>表示一旦得到某个变量的地址，就不能再指向其他的变量</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>指针常量</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> * <span class=\"type\">const</span> q = &amp;i; <span class=\"comment\">// q 是 const</span></span><br><span class=\"line\">*q = <span class=\"number\">22</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">q++;  <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">q = &amp;j;  <span class=\"comment\">// ERROR </span></span><br></pre></td></tr></table></figure>\n<h5 id=\"所指的是-const常量指针\"><a class=\"anchor\" href=\"#所指的是-const常量指针\">#</a> 所指的是 const（常量指针）</h5>\n<ul>\n<li>表示不能通过指针去修改那个变量（指针的指向可以修改，但是指针指向的值不能修改）</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>常量指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *p = &amp;i;</span><br><span class=\"line\">*p = <span class=\"number\">26</span>; <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">i = <span class=\"number\">26</span>;  <span class=\"comment\">// OK</span></span><br><span class=\"line\">p = &amp;j; <span class=\"comment\">// OK </span></span><br></pre></td></tr></table></figure>\n<h5 id=\"保护数组的值\"><a class=\"anchor\" href=\"#保护数组的值\">#</a> 保护数组的值</h5>\n<ul>\n<li>因为把数组传入函数时传递的是地址，所以函数内部可以修改数组的值</li>\n<li>为了保护数组的值不被函数破坏，可以将参数设置为 const</li>\n<li>int sum(const int a[], int length);</li>\n</ul>\n<h4 id=\"空指针与野指针\"><a class=\"anchor\" href=\"#空指针与野指针\">#</a> 空指针与野指针</h4>\n<h5 id=\"空指针\"><a class=\"anchor\" href=\"#空指针\">#</a> 空指针</h5>\n<ul>\n<li>空指针用于给指针变量进行初始化： <code>int *p = NULL</code></li>\n<li>空指针是不能进行访问的，即 <code>*p = 100</code>  是不允许的</li>\n</ul>\n<h5 id=\"野指针\"><a class=\"anchor\" href=\"#野指针\">#</a> 野指针</h5>\n<h4 id=\"指针运算\"><a class=\"anchor\" href=\"#指针运算\">#</a> 指针运算</h4>\n<p>*(p + n) &lt;==&gt; a[n]</p>\n<p>*p++  （优先级）</p>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/%E5%87%BD%E6%95%B0/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/%E5%87%BD%E6%95%B0/",
            "title": "函数",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"函数\"><a class=\"anchor\" href=\"#函数\">#</a> 函数</h1>\n<blockquote>\n<p><strong>实际参数</strong>和<strong>形式参数</strong></p>\n<p>实际参数是出现在函数调用时圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。</p>\n</blockquote>\n<blockquote>\n<p><strong>函数原型</strong></p>\n<p>函数头以分号结尾，就构成了函数原型，目的是告诉编译器函数长什么样子。</p>\n</blockquote>\n<blockquote>\n<p><strong>类型不匹配</strong></p>\n<p>调用函数时给的参数值与参数的类型不匹配，但是编译器会将类型转换好，很可能不是自己所想要的。</p>\n</blockquote>\n<blockquote>\n<p>C 语言在调用函数时，永远只能传值给函数。</p>\n</blockquote>\n<blockquote>\n<p><strong>本地（局部）变量</strong></p>\n<ul>\n<li>定义在块内的\n<ul>\n<li>定义在函数块内</li>\n<li>定义在语句块内</li>\n<li>也可以是随便拉一对大括号来定义变量</li>\n</ul>\n</li>\n<li>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了</li>\n<li>块外面定义的变量在块里面仍然有效</li>\n<li>块里面定义了和块外面同名的变量则覆盖了外面的</li>\n<li>不能在一个块内定义同名的变量</li>\n<li>本地变量不会被默认初始化</li>\n<li>参数在进入函数的时候就被初始化了</li>\n<li><strong>返回本地变量的地址是危险的</strong>，因为本地变量是存放在栈区的，栈区的变量在函数结束时会自动释放。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>全局变量</strong></p>\n<ul>\n<li>定义在函数外面的变量是全局变量</li>\n<li>全局变量有全局的生存期和作用域\n<ul>\n<li>它们与任何函数都无关</li>\n<li>在任何函数内部都可以使用它们</li>\n</ul>\n</li>\n<li>没有做初始化的全局变量会得到 0 值，本地变量不会\n<ul>\n<li>指针会得到 NULL</li>\n</ul>\n</li>\n<li>只能用编译时刻已知的值为全局变量进行初始化</li>\n<li>它们的初始化发生在 main 函数之前</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>静态本地变量</strong></p>\n<ul>\n<li>在本地变量定义时加上 static 修饰符就可以成为静态本地变量</li>\n<li>当函数离开时，静态本地变量会继续保持其值</li>\n<li>静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值</li>\n<li>静态本地变量实际上是特殊的全局变量</li>\n<li>它们位于相同的内存区域</li>\n<li>静态本地变量具有全局的生存期和函数内部的作用域</li>\n</ul>\n</blockquote>\n<ul>\n<li>不要使用全局变量来在函数间传递参数结果</li>\n<li>尽量避免使用全局变量</li>\n<li>使用全局变量和静态本地变量是线程不安全的</li>\n</ul>\n<h3 id=\"函数的一些高级特性\"><a class=\"anchor\" href=\"#函数的一些高级特性\">#</a> 函数的一些高级特性</h3>\n<h4 id=\"函数的默认参数\"><a class=\"anchor\" href=\"#函数的默认参数\">#</a> 函数的默认参数</h4>\n<p>在 C++ 中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法： <code>返回值类型 函数名(参数 = 默认值) &#123;&#125;</code></p>\n<p>注意事项：</p>\n<ol>\n<li>如果某个位置已经有了默认参数，那么从这个参数以后，都必须有默认值；</li>\n<li>函数的声明和实现只能由一个写默认参数</li>\n</ol>\n<h4 id=\"函数的重载\"><a class=\"anchor\" href=\"#函数的重载\">#</a> 函数的重载</h4>\n<p>意义：函数名可以相同，提高复用性</p>\n<p><strong>函数重载需要满足的条件：</strong></p>\n<ul>\n<li>同一个作用域下</li>\n<li>函数名相同</li>\n<li>函数参数类型不同或者个数不同或者顺序不同</li>\n<li><strong>函数的返回值不能作为函数重载的条件</strong></li>\n</ul>\n<p><strong>函数重载的注意事项：</strong></p>\n<ol>\n<li>\n<p>引用作为函数重载的条件</p>\n<figure class=\"highlight c\"><figcaption><span>函数注意事项</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;func(int &amp;a) 调用&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> &amp;a)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;func(const int &amp;a) 调用&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// int &amp;a = 10; 这句话是错误的，因为引用必须引用合法的内存空间，所以这句话是错误的</span></span><br><span class=\"line\">\t<span class=\"comment\">// 那么我们想要调用上面这两个函数，方法如下：</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> &amp;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\tfunc(a);</span><br><span class=\"line\">\tfunc(<span class=\"number\">10</span>); <span class=\"comment\">// const int &amp;a = 10;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数重载碰到函数的默认参数</p>\n</li>\n</ol>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/%E7%BB%93%E6%9E%84%E4%BD%93/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/%E7%BB%93%E6%9E%84%E4%BD%93/",
            "title": "结构体",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"结构类型-宏\"><a class=\"anchor\" href=\"#结构类型-宏\">#</a> 结构类型、宏</h1>\n<h3 id=\"结构类型\"><a class=\"anchor\" href=\"#结构类型\">#</a> 结构类型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> month;</span><br><span class=\"line\">    <span class=\"type\">int</span> day;</span><br><span class=\"line\">    <span class=\"type\">int</span> year;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义变量（还有其他方法）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span>;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span> =</span> &#123;.month = <span class=\"number\">7</span>, .year = <span class=\"number\">2023</span>&#125;;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span> =</span> &#123;<span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">2023</span>&#125;; </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 访问成员</span></span><br><span class=\"line\"> today.month</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 结构指针</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> *<span class=\"title\">pDate</span> =</span> &amp;today;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指针所指的结构变量的成员</span></span><br><span class=\"line\">(*pDate).month = <span class=\"number\">12</span>;</span><br><span class=\"line\">pDate-&gt;month = <span class=\"number\">12</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义数据类型\"><a class=\"anchor\" href=\"#自定义数据类型\">#</a> 自定义数据类型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ADate</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> month;</span><br><span class=\"line\">    <span class=\"type\">int</span> day;</span><br><span class=\"line\">    <span class=\"type\">int</span> year;</span><br><span class=\"line\">&#125; Date;</span><br></pre></td></tr></table></figure>\n<h3 id=\"宏\"><a class=\"anchor\" href=\"#宏\">#</a> 宏</h3>\n<h4 id=\"编译预处理指令\"><a class=\"anchor\" href=\"#编译预处理指令\">#</a> 编译预处理指令</h4>\n<ul>\n<li>#开头的是编译预处理指令</li>\n<li>它们不是 C 语言的成分，但是 C 语言程序离不开它们</li>\n<li>#define 用来定义一个宏\n<ul>\n<li>\n<pre><code class=\"language-C\">// 结尾没有分号，因为不是 C 的语句\n#define PI 3.14159\n</code></pre>\n</li>\n</ul>\n</li>\n<li>如果一个宏的值中有其他宏的名字，也是会被替换的</li>\n<li>如果一个宏的值超过一行，最后一行之前的行末需要加 \\</li>\n<li>宏的值后面出现的注释不会被当作宏的一部分</li>\n<li>宏可以带参数（像函数一样）</li>\n</ul>\n<hr>\n<p>C 语言包含哪些数据类型？</p>\n<ol>\n<li>整数\n<ol>\n<li>char：1 字节</li>\n<li>short：2 字节</li>\n<li>int：取决于编译器，通常的意义是 “1 个字”</li>\n<li>long：取决于编译器</li>\n<li>long long：8 字节</li>\n</ol>\n</li>\n<li>浮点数\n<ol>\n<li>float</li>\n<li>double</li>\n<li>long double</li>\n</ol>\n</li>\n<li>逻辑\n<ol>\n<li>bool</li>\n</ol>\n</li>\n<li>指针</li>\n<li>自定义类型</li>\n</ol>\n<blockquote>\n<p>C 语言提供了 sizeof（静态运算符） 来给出某个类型或者某个变量在内存中所占据的字节数</p>\n<p>整数在计算机中以补码的形式存在。比如 char 类型的变量 c = 255， 那么我们以整数的方式输出，得到的是 -1，如果想让该字符就是 255，那么可以加上 unsigned 关键字</p>\n</blockquote>\n<ul>\n<li>在使用和定义这个函数的地方都应该 #include 这个头文件（文本插入）</li>\n</ul>\n<blockquote>\n<p><strong>声明和定义</strong></p>\n<p>int i; 变量的定义</p>\n<p>extern int i; 变量的声明（在头文件中）</p>\n<ul>\n<li>声明是不产生代码的东西\n<ul>\n<li>函数原型</li>\n<li>变量声明</li>\n<li>结构声明</li>\n<li>宏声明</li>\n<li>枚举声明</li>\n<li>类型声明</li>\n<li>inline 函数</li>\n</ul>\n</li>\n<li>定义是产生代码的东西</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/os/FreeRTOS/",
            "url": "https://lktwh.github.io/2023/10/03/os/FreeRTOS/",
            "title": "FreeRTOS",
            "date_published": "2023-10-03T14:26:00.000Z",
            "content_html": "<h2 id=\"操作系统\"><a class=\"anchor\" href=\"#操作系统\">#</a> 操作系统</h2>\n<p>一个操作系统的主要功能主要有：</p>\n<ul>\n<li>任务（应用程序）的调度管理</li>\n<li>堆栈和内存管理</li>\n<li>文件管理</li>\n<li>队列管理</li>\n<li>中断和定时器管理</li>\n<li>资源管理</li>\n<li>输入输出管理</li>\n</ul>\n<h2 id=\"实时操作系统rtos\"><a class=\"anchor\" href=\"#实时操作系统rtos\">#</a> 实时操作系统（RTOS）</h2>\n<p>​\t\t是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。提供及时响应和高可靠性是其主要特点。</p>\n<p>​\t\t<strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2ZlYXR1cmVzLmh0bWw=\">FreeRTOS 开发者文档</span></strong></p>\n<h2 id=\"freertos-源码概述\"><a class=\"anchor\" href=\"#freertos-源码概述\">#</a> FreeRTOS 源码概述</h2>\n<h3 id=\"freertos-目录结构\"><a class=\"anchor\" href=\"#freertos-目录结构\">#</a> FreeRTOS 目录结构</h3>\n<p><img data-src=\"/assets/freertos1.png\" alt=\"\"></p>\n<h3 id=\"核心文件的作用\"><a class=\"anchor\" href=\"#核心文件的作用\">#</a> 核心文件的作用</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Source 下的文件</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">task.c</td>\n<td style=\"text-align:center\">必需， 任务操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">list.c</td>\n<td style=\"text-align:center\">必需，列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">queue.c</td>\n<td style=\"text-align:center\">基本必需，提供队列操作、信号量 (semaphore) 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timer.c</td>\n<td style=\"text-align:center\">可选，software timer</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">event_groups.c</td>\n<td style=\"text-align:center\">可选，提供 event group 功能</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">croutine.c</td>\n<td style=\"text-align:center\">可选，过时了</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"堆和栈\"><a class=\"anchor\" href=\"#堆和栈\">#</a> 堆和栈</h2>\n<blockquote>\n<ul>\n<li>堆，heap，就是一块空闲的内存，需要提供管理函数\n<ul>\n<li>malloc：从堆里划出一块空间给程序使用</li>\n<li>free：用完后，再把它标记为 &quot;空闲&quot; 的，可以再次使用</li>\n</ul>\n</li>\n<li>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中\n<ul>\n<li>可以从堆中分配一块空间用作栈</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>每个 FreeRTOS 任务都需要<strong>自己的栈空间</strong>（任务栈），用来保存每个任务自己的现场、自己的局部变量以及调用关系</p>\n<h2 id=\"内存管理\"><a class=\"anchor\" href=\"#内存管理\">#</a> 内存管理</h2>\n<p>内存管理就是如何如使用 FreeRTOS 中的堆。每次创建任务、队列、互斥锁、软件定时器、信号量或事件组时，RTOS 内核都需要 RAM ， RAM 可以从 RTOS API 对象创建函数内的 RTOS 堆自动动态分配。</p>\n<p>在 C 语言的库函数中，由 malloc、free 等函数，但是它们不适用在 FreeRTOS 中：</p>\n<ul>\n<li>不适合用在资源紧缺的嵌入式系统中</li>\n<li>这些函数的实现过于复杂、占据的代码空间太大</li>\n<li>并非线程安全的 (thread- safe)</li>\n<li>运行有不确定性：每次调用这些函数时花费的时间可能都不相同</li>\n<li>内存碎片化</li>\n<li>使用不同的编译器时，需要进行复杂的配置</li>\n<li>有时候难以调试</li>\n</ul>\n<p>因此，FreeRTOS 提供了几套复杂性和功能各不行同的堆的管理方案，我们可以根据自己的需求，选择合适的方案。</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMQ==\">heap_1</span> —— 最简单，不允许释放内存。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMg==\">heap_2</span>—— 允许释放内存，但不会合并相邻的空闲块。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMw==\">heap_3</span> —— 简单包装了标准 malloc () 和 free ()，以保证线程安全。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfNA==\">heap_4</span> —— 合并相邻的空闲块以避免碎片化。 包含绝对地址放置选项。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfNQ==\">heap_5 </span>—— 如同 heap_4，能够跨越多个<strong>不相邻内存区域的堆</strong>。比如我不仅可以使用片上的 RAM ，还可以使用片外的 RAM。</li>\n</ul>\n<p>在这些方案中 heap_4 较为常用</p>\n<h3 id=\"heap_4\"><a class=\"anchor\" href=\"#heap_4\">#</a> heap_4</h3>\n<p>Heap_4 会把相邻空闲内存合并为一个大的空闲内存，可以较少内存的碎片化问题。适用于这种场景：频繁地分配、释放不同大小的内存。</p>\n<p>内存堆仍然是一个大数组，定义为：</p>\n<figure class=\"highlight c\"><figcaption><span>堆定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br></pre></td></tr></table></figure>\n<p>可用堆空间的总量通过  <code>configTOTAL_HEAP_SIZE</code>  设置（位于  <code>FreeRTOSConfig.h</code>  中）</p>\n<p>heap_4 的功能：</p>\n<ul>\n<li>即使应用程序重复删除任务、队列、 信号量、互斥锁等，仍然可用。</li>\n<li>与 heap_2 实现相比，导致堆空间严重碎片化成多个小块的可能性更小 （即使正在分配和释放的内存是随机大小） 。</li>\n<li>不具有确定性，但比大多数标准 C 库 malloc 实现更有效。</li>\n</ul>\n<h3 id=\"使用的-api\"><a class=\"anchor\" href=\"#使用的-api\">#</a> 使用的 API</h3>\n<figure class=\"highlight c\"><figcaption><span>堆相关 API</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xSize )</span>   <span class=\"comment\">//内存申请函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vPortFree</span><span class=\"params\">( <span class=\"type\">void</span> *pv )</span>  <span class=\"comment\">//内存释放函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vPortInitialiseBlocks</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//初始化内存堆函数</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//获取当前未分配的内存堆大小</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetMinimumEverFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//获取未分配的内存堆历史最小值</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"任务管理\"><a class=\"anchor\" href=\"#任务管理\">#</a> 任务管理</h2>\n<p>在使用 FeeRTOS 时，我们在 application 中创建多个任务。</p>\n<h3 id=\"什么是任务\"><a class=\"anchor\" href=\"#什么是任务\">#</a> 什么是任务</h3>\n<p>在 FreeRTOS 中，任务就是一个函数，原型如下，通常包含一个永远不会退出的循环体</p>\n<figure class=\"highlight c\"><figcaption><span>任务函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */</span></span><br><span class=\"line\">\t<span class=\"type\">int32_t</span> lVariableExample = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 任务函数通常实现为一个无限循环 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( ;; )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 任务的代码 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 如果程序从循环中退出，一定要使用vTaskDelete删除自己</span></span><br><span class=\"line\"><span class=\"comment\">     * NULL表示删除的是自己</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">\tvTaskDelete( <span class=\"literal\">NULL</span> );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 程序不会执行到这里, 如果执行到这里就出错了 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的点：</p>\n<ul>\n<li>这个函数不能有返回值</li>\n<li>同一个函数，可以用来创建多个任务。即多个任务可以运行同一个函数</li>\n<li>如果不需要这个任务，必须使用语句显示地删除这个任务</li>\n<li>每一个任务都有自己的栈以及优先级</li>\n<li>在每个函数内部，尽量使用局部变量\n<ul>\n<li>每个任务有自己的栈</li>\n<li>每个任务运行这个函数时\n<ul>\n<li>任务 A 的局部变量放在任务 A 的栈中，任务 B 的局部变量放在任务 B 的栈中</li>\n<li>不同任务的局部变量，都有自己的副本</li>\n</ul>\n</li>\n<li>如果函数使用全局变量、静态变量的话\n<ul>\n<li>多个任务使用的是同一个副本</li>\n<li>需要防止冲突</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"任务创建\"><a class=\"anchor\" href=\"#任务创建\">#</a> 任务创建</h3>\n<p>函数如下：</p>\n<figure class=\"highlight c\"><figcaption><span>任务创建函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreate</span><span class=\"params\">( TaskFunction_t pxTaskCode, <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName, <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters, <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">                        UBaseType_t uxPriority,    <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">                        TaskHandle_t * <span class=\"type\">const</span> pxCreatedTask )</span>; <span class=\"comment\">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ol>\n<li>pvTaskCode ：函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 vTaskDelete</li>\n<li>pcName ：任务的名称，仅用于调试目的，长度为 configMAX_TASK_NAME_LEN</li>\n<li>usStackDepth ：每个任务都有自己的栈，该参数指定了栈的大小，单位为 word。例如传入的是 100，表示栈的大小为 400 字节。确定栈的大小最精确的方法是使用反汇编</li>\n<li>pvParameters ：调用的任务函数时使用的参数</li>\n<li>uxPriority ：任务的优先级范围 0 ~ configMAX_PROORITIES - 1。数值越小，优先级越低。如果传入的值过大，xTaskCreate 会将其调整为 configMAX_PRIORITIES – 1</li>\n<li>pxCreatedTask ：用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要堆该任务进行操作，例如修改优先级，则需要使用该句柄。如果不需要该句柄，则传入 NULL</li>\n</ol>\n<h3 id=\"任务删除\"><a class=\"anchor\" href=\"#任务删除\">#</a> 任务删除</h3>\n<p>任务删除函数：</p>\n<figure class=\"highlight c\"><figcaption><span>任务删除函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelete</span><span class=\"params\">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>pvTaskCode ：任务句柄，使用 xTaskCreate 创建任务时可以得到一个句柄。也可以传入 NULL，表示删除自己。</li>\n</ul>\n<h3 id=\"任务优先级\"><a class=\"anchor\" href=\"#任务优先级\">#</a> 任务优先级</h3>\n",
            "tags": [
                "操作系统",
                "FreeRTOS"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/stm32/F103/",
            "url": "https://lktwh.github.io/2023/10/03/stm32/F103/",
            "title": "STM32F103",
            "date_published": "2023-10-03T12:14:00.000Z",
            "content_html": "",
            "tags": [
                "单片机",
                "STM32"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/datastructure/stack/",
            "url": "https://lktwh.github.io/2023/10/03/datastructure/stack/",
            "title": "栈",
            "date_published": "2023-10-03T12:14:00.000Z",
            "content_html": "<p>这里开始正文。。。。。</p>\n<ul>\n<li>[算法，算法 - 新手]  表示在算法下的子目录，算法 - 新手下</li>\n<li>Java \t\t\t\t表示在 java 分类下</li>\n</ul>\n",
            "tags": [
                "数据结构",
                "栈"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/hello-world/",
            "url": "https://lktwh.github.io/2023/10/03/hello-world/",
            "title": "Hello World",
            "date_published": "2023-10-03T10:52:37.910Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}