{
    "version": "https://jsonfeed.org/version/1",
    "title": "一个真正的鳗",
    "subtitle": "真正的鳗",
    "icon": "https://lktwh.github.io/images/favicon.ico",
    "description": "真正的鳗",
    "home_page_url": "https://lktwh.github.io",
    "items": [
        {
            "id": "https://lktwh.github.io/2023/10/03/os/FreeRTOS/",
            "url": "https://lktwh.github.io/2023/10/03/os/FreeRTOS/",
            "title": "FreeRTOS",
            "date_published": "2023-10-03T14:26:00.000Z",
            "content_html": "<h2 id=\"操作系统\"><a class=\"anchor\" href=\"#操作系统\">#</a> 操作系统</h2>\n<p>一个操作系统的主要功能主要有：</p>\n<ul>\n<li>任务（应用程序）的调度管理</li>\n<li>堆栈和内存管理</li>\n<li>文件管理</li>\n<li>队列管理</li>\n<li>中断和定时器管理</li>\n<li>资源管理</li>\n<li>输入输出管理</li>\n</ul>\n<h2 id=\"实时操作系统rtos\"><a class=\"anchor\" href=\"#实时操作系统rtos\">#</a> 实时操作系统（RTOS）</h2>\n<p>​\t\t是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。提供及时响应和高可靠性是其主要特点。</p>\n<p>​\t\t<strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2ZlYXR1cmVzLmh0bWw=\">FreeRTOS 开发者文档</span></strong></p>\n<h2 id=\"freertos-源码概述\"><a class=\"anchor\" href=\"#freertos-源码概述\">#</a> FreeRTOS 源码概述</h2>\n<h3 id=\"freertos-目录结构\"><a class=\"anchor\" href=\"#freertos-目录结构\">#</a> FreeRTOS 目录结构</h3>\n<p><img data-src=\"/assets/freertos1.png\" alt=\"\"></p>\n<h3 id=\"核心文件的作用\"><a class=\"anchor\" href=\"#核心文件的作用\">#</a> 核心文件的作用</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Source 下的文件</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">task.c</td>\n<td style=\"text-align:center\">必需， 任务操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">list.c</td>\n<td style=\"text-align:center\">必需，列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">queue.c</td>\n<td style=\"text-align:center\">基本必需，提供队列操作、信号量 (semaphore) 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timer.c</td>\n<td style=\"text-align:center\">可选，software timer</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">event_groups.c</td>\n<td style=\"text-align:center\">可选，提供 event group 功能</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">croutine.c</td>\n<td style=\"text-align:center\">可选，过时了</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"堆和栈\"><a class=\"anchor\" href=\"#堆和栈\">#</a> 堆和栈</h2>\n<blockquote>\n<ul>\n<li>堆，heap，就是一块空闲的内存，需要提供管理函数\n<ul>\n<li>malloc：从堆里划出一块空间给程序使用</li>\n<li>free：用完后，再把它标记为 &quot;空闲&quot; 的，可以再次使用</li>\n</ul>\n</li>\n<li>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中\n<ul>\n<li>可以从堆中分配一块空间用作栈</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>每个 FreeRTOS 任务都需要<strong>自己的栈空间</strong>（任务栈），用来保存每个任务自己的现场、自己的局部变量以及调用关系</p>\n<h2 id=\"内存管理\"><a class=\"anchor\" href=\"#内存管理\">#</a> 内存管理</h2>\n<p>内存管理就是如何如使用 FreeRTOS 中的堆。每次创建任务、队列、互斥锁、软件定时器、信号量或事件组时，RTOS 内核都需要 RAM ， RAM 可以从 RTOS API 对象创建函数内的 RTOS 堆自动动态分配。</p>\n<p>在 C 语言的库函数中，由 malloc、free 等函数，但是它们不适用在 FreeRTOS 中：</p>\n<ul>\n<li>不适合用在资源紧缺的嵌入式系统中</li>\n<li>这些函数的实现过于复杂、占据的代码空间太大</li>\n<li>并非线程安全的 (thread- safe)</li>\n<li>运行有不确定性：每次调用这些函数时花费的时间可能都不相同</li>\n<li>内存碎片化</li>\n<li>使用不同的编译器时，需要进行复杂的配置</li>\n<li>有时候难以调试</li>\n</ul>\n<p>因此，FreeRTOS 提供了几套复杂性和功能各不行同的堆的管理方案，我们可以根据自己的需求，选择合适的方案。</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMQ==\">heap_1</span> —— 最简单，不允许释放内存。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMg==\">heap_2</span>—— 允许释放内存，但不会合并相邻的空闲块。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMw==\">heap_3</span> —— 简单包装了标准 malloc () 和 free ()，以保证线程安全。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfNA==\">heap_4</span> —— 合并相邻的空闲块以避免碎片化。 包含绝对地址放置选项。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfNQ==\">heap_5 </span>—— 如同 heap_4，能够跨越多个<strong>不相邻内存区域的堆</strong>。比如我不仅可以使用片上的 RAM ，还可以使用片外的 RAM。</li>\n</ul>\n<p>在这些方案中 heap_4 较为常用</p>\n<h3 id=\"heap_4\"><a class=\"anchor\" href=\"#heap_4\">#</a> heap_4</h3>\n<p>Heap_4 会把相邻空闲内存合并为一个大的空闲内存，可以较少内存的碎片化问题。适用于这种场景：频繁地分配、释放不同大小的内存。</p>\n<p>内存堆仍然是一个大数组，定义为：</p>\n<figure class=\"highlight c\"><figcaption><span>堆定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br></pre></td></tr></table></figure>\n<p>可用堆空间的总量通过  <code>configTOTAL_HEAP_SIZE</code>  设置（位于  <code>FreeRTOSConfig.h</code>  中）</p>\n<p>heap_4 的功能：</p>\n<ul>\n<li>即使应用程序重复删除任务、队列、 信号量、互斥锁等，仍然可用。</li>\n<li>与 heap_2 实现相比，导致堆空间严重碎片化成多个小块的可能性更小 （即使正在分配和释放的内存是随机大小） 。</li>\n<li>不具有确定性，但比大多数标准 C 库 malloc 实现更有效。</li>\n</ul>\n<h3 id=\"使用的-api\"><a class=\"anchor\" href=\"#使用的-api\">#</a> 使用的 API</h3>\n<figure class=\"highlight c\"><figcaption><span>堆相关 API</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xSize )</span>   <span class=\"comment\">//内存申请函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vPortFree</span><span class=\"params\">( <span class=\"type\">void</span> *pv )</span>  <span class=\"comment\">//内存释放函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vPortInitialiseBlocks</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//初始化内存堆函数</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//获取当前未分配的内存堆大小</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetMinimumEverFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//获取未分配的内存堆历史最小值</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"任务管理\"><a class=\"anchor\" href=\"#任务管理\">#</a> 任务管理</h2>\n<p>在使用 FeeRTOS 时，我们在 application 中创建多个任务。</p>\n<h3 id=\"什么是任务\"><a class=\"anchor\" href=\"#什么是任务\">#</a> 什么是任务</h3>\n<p>在 FreeRTOS 中，任务就是一个函数，原型如下，通常包含一个永远不会退出的循环体</p>\n<figure class=\"highlight c\"><figcaption><span>任务函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */</span></span><br><span class=\"line\">\t<span class=\"type\">int32_t</span> lVariableExample = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 任务函数通常实现为一个无限循环 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( ;; )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 任务的代码 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 如果程序从循环中退出，一定要使用vTaskDelete删除自己</span></span><br><span class=\"line\"><span class=\"comment\">     * NULL表示删除的是自己</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">\tvTaskDelete( <span class=\"literal\">NULL</span> );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 程序不会执行到这里, 如果执行到这里就出错了 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的点：</p>\n<ul>\n<li>这个函数不能有返回值</li>\n<li>同一个函数，可以用来创建多个任务。即多个任务可以运行同一个函数</li>\n<li>如果不需要这个任务，必须使用语句显示地删除这个任务</li>\n<li>每一个任务都有自己的栈以及优先级</li>\n<li>在每个函数内部，尽量使用局部变量\n<ul>\n<li>每个任务有自己的栈</li>\n<li>每个任务运行这个函数时\n<ul>\n<li>任务 A 的局部变量放在任务 A 的栈中，任务 B 的局部变量放在任务 B 的栈中</li>\n<li>不同任务的局部变量，都有自己的副本</li>\n</ul>\n</li>\n<li>如果函数使用全局变量、静态变量的话\n<ul>\n<li>多个任务使用的是同一个副本</li>\n<li>需要防止冲突</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"任务创建\"><a class=\"anchor\" href=\"#任务创建\">#</a> 任务创建</h3>\n<p>函数如下：</p>\n<figure class=\"highlight c\"><figcaption><span>任务创建函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreate</span><span class=\"params\">( TaskFunction_t pxTaskCode, <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName, <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters, <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">                        UBaseType_t uxPriority,    <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">                        TaskHandle_t * <span class=\"type\">const</span> pxCreatedTask )</span>; <span class=\"comment\">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ol>\n<li>pvTaskCode ：函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 vTaskDelete</li>\n<li>pcName ：任务的名称，仅用于调试目的，长度为 configMAX_TASK_NAME_LEN</li>\n<li>usStackDepth ：每个任务都有自己的栈，该参数指定了栈的大小，单位为 word。例如传入的是 100，表示栈的大小为 400 字节。确定栈的大小最精确的方法是使用反汇编</li>\n<li>pvParameters ：调用的任务函数时使用的参数</li>\n<li>uxPriority ：任务的优先级范围 0 ~ configMAX_PROORITIES - 1。数值越小，优先级越低。如果传入的值过大，xTaskCreate 会将其调整为 configMAX_PRIORITIES – 1</li>\n<li>pxCreatedTask ：用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要堆该任务进行操作，例如修改优先级，则需要使用该句柄。如果不需要该句柄，则传入 NULL</li>\n</ol>\n<h3 id=\"任务删除\"><a class=\"anchor\" href=\"#任务删除\">#</a> 任务删除</h3>\n<p>任务删除函数：</p>\n<figure class=\"highlight c\"><figcaption><span>任务删除函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelete</span><span class=\"params\">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>pvTaskCode ：任务句柄，使用 xTaskCreate 创建任务时可以得到一个句柄。也可以传入 NULL，表示删除自己。</li>\n</ul>\n<h3 id=\"任务优先级\"><a class=\"anchor\" href=\"#任务优先级\">#</a> 任务优先级</h3>\n",
            "tags": [
                "操作系统",
                "FreeRTOS"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/datastructure/stack/",
            "url": "https://lktwh.github.io/2023/10/03/datastructure/stack/",
            "title": "栈",
            "date_published": "2023-10-03T12:14:00.000Z",
            "content_html": "<p>这里开始正文。。。。。</p>\n<ul>\n<li>[算法，算法 - 新手]  表示在算法下的子目录，算法 - 新手下</li>\n<li>Java \t\t\t\t表示在 java 分类下</li>\n</ul>\n",
            "tags": [
                "数据结构",
                "栈"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/stm32/F103/",
            "url": "https://lktwh.github.io/2023/10/03/stm32/F103/",
            "title": "STM32F103",
            "date_published": "2023-10-03T12:14:00.000Z",
            "content_html": "",
            "tags": [
                "单片机",
                "STM32"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/hello-world/",
            "url": "https://lktwh.github.io/2023/10/03/hello-world/",
            "title": "Hello World",
            "date_published": "2023-10-03T10:52:37.910Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}