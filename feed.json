{
    "version": "https://jsonfeed.org/version/1",
    "title": "一个真正的鳗",
    "subtitle": "真正的鳗",
    "icon": "https://lktwh.github.io/images/favicon.ico",
    "description": "真正的鳗",
    "home_page_url": "https://lktwh.github.io",
    "items": [
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/ROS/ROS/",
            "url": "https://lktwh.github.io/2023/10/13/robot/ROS/ROS/",
            "title": "ROS1",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"第一章ros-相关概念和环境搭建\"><a class=\"anchor\" href=\"#第一章ros-相关概念和环境搭建\">#</a> 第一章：ROS 相关概念和环境搭建</h1>\n<h1 id=\"第二章ros-通信机制\"><a class=\"anchor\" href=\"#第二章ros-通信机制\">#</a> 第二章：ROS 通信机制</h1>\n<h2 id=\"话题通信\"><a class=\"anchor\" href=\"#话题通信\">#</a> 话题通信</h2>\n<p>话题通信是基于发布订阅模式的，即一个节点发布消息，另一个节点订阅该消息。比如下面的应用场景：</p>\n<blockquote>\n<p>机器人在执行道航功能，使用的传感器是激光雷达，机器人会采集激光雷达感知到的信息并计算，然后生成运动控制信息驱动机器人底盘运动</p>\n<p>在上述场景中不止一次使用到了话题通信</p>\n<ol>\n<li>激光雷达信息的采集处理为例：在 ROS 中有一个节点需要实时发布雷达当前采集到的数据，导航模块中也有节点订阅并解析雷达数据；</li>\n<li>运动消息发布为例：导航模块会根据传感器采集的数据实时地计算出运动控制信息并发送给底盘，底盘也可以有一个节点订阅运动控制信息最终转换成为控制电机的脉冲信号</li>\n</ol>\n</blockquote>\n<p>话题通信主要应用于不断更新的、少逻辑处理的数据传输场景</p>\n<h3 id=\"话题通信的理论模型\"><a class=\"anchor\" href=\"#话题通信的理论模型\">#</a> 话题通信的理论模型</h3>\n<p>角色：</p>\n<ol>\n<li>master  —&gt; 管理者</li>\n<li>talker    —&gt; 发布者</li>\n<li>listener —&gt; 订阅者、</li>\n</ol>\n<p>流程：</p>\n",
            "tags": [
                "机器人",
                "ROS",
                "ROS"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/%E5%87%BD%E6%95%B0/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/%E5%87%BD%E6%95%B0/",
            "title": "函数",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"函数\"><a class=\"anchor\" href=\"#函数\">#</a> 函数</h1>\n<blockquote>\n<p><strong>实际参数</strong>和<strong>形式参数</strong></p>\n<p>实际参数是出现在函数调用时圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。</p>\n</blockquote>\n<blockquote>\n<p><strong>函数原型</strong></p>\n<p>函数头以分号结尾，就构成了函数原型，目的是告诉编译器函数长什么样子。</p>\n</blockquote>\n<blockquote>\n<p><strong>类型不匹配</strong></p>\n<p>调用函数时给的参数值与参数的类型不匹配，但是编译器会将类型转换好，很可能不是自己所想要的。</p>\n</blockquote>\n<blockquote>\n<p>C 语言在调用函数时，永远只能传值给函数。</p>\n</blockquote>\n<blockquote>\n<p><strong>本地（局部）变量</strong></p>\n<ul>\n<li>定义在块内的\n<ul>\n<li>定义在函数块内</li>\n<li>定义在语句块内</li>\n<li>也可以是随便拉一对大括号来定义变量</li>\n</ul>\n</li>\n<li>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了</li>\n<li>块外面定义的变量在块里面仍然有效</li>\n<li>块里面定义了和块外面同名的变量则覆盖了外面的</li>\n<li>不能在一个块内定义同名的变量</li>\n<li>本地变量不会被默认初始化</li>\n<li>参数在进入函数的时候就被初始化了</li>\n<li><strong>返回本地变量的地址是危险的</strong>，因为本地变量是存放在栈区的，栈区的变量在函数结束时会自动释放。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>全局变量</strong></p>\n<ul>\n<li>定义在函数外面的变量是全局变量</li>\n<li>全局变量有全局的生存期和作用域\n<ul>\n<li>它们与任何函数都无关</li>\n<li>在任何函数内部都可以使用它们</li>\n</ul>\n</li>\n<li>没有做初始化的全局变量会得到 0 值，本地变量不会\n<ul>\n<li>指针会得到 NULL</li>\n</ul>\n</li>\n<li>只能用编译时刻已知的值为全局变量进行初始化</li>\n<li>它们的初始化发生在 main 函数之前</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>静态本地变量</strong></p>\n<ul>\n<li>在本地变量定义时加上 static 修饰符就可以成为静态本地变量</li>\n<li>当函数离开时，静态本地变量会继续保持其值</li>\n<li>静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值</li>\n<li>静态本地变量实际上是特殊的全局变量</li>\n<li>它们位于相同的内存区域</li>\n<li>静态本地变量具有全局的生存期和函数内部的作用域</li>\n</ul>\n</blockquote>\n<ul>\n<li>不要使用全局变量来在函数间传递参数结果</li>\n<li>尽量避免使用全局变量</li>\n<li>使用全局变量和静态本地变量是线程不安全的</li>\n</ul>\n<h3 id=\"函数的一些高级特性\"><a class=\"anchor\" href=\"#函数的一些高级特性\">#</a> 函数的一些高级特性</h3>\n<h4 id=\"函数的默认参数\"><a class=\"anchor\" href=\"#函数的默认参数\">#</a> 函数的默认参数</h4>\n<p>在 C++ 中，函数的形参列表中的形参是可以有默认值的。</p>\n<p>语法： <code>返回值类型 函数名(参数 = 默认值) &#123;&#125;</code></p>\n<p>注意事项：</p>\n<ol>\n<li>如果某个位置已经有了默认参数，那么从这个参数以后，都必须有默认值；</li>\n<li>函数的声明和实现只能由一个写默认参数</li>\n</ol>\n<h4 id=\"函数的重载\"><a class=\"anchor\" href=\"#函数的重载\">#</a> 函数的重载</h4>\n<p>意义：函数名可以相同，提高复用性</p>\n<p><strong>函数重载需要满足的条件：</strong></p>\n<ul>\n<li>同一个作用域下</li>\n<li>函数名相同</li>\n<li>函数参数类型不同或者个数不同或者顺序不同</li>\n<li><strong>函数的返回值不能作为函数重载的条件</strong></li>\n</ul>\n<p><strong>函数重载的注意事项：</strong></p>\n<ol>\n<li>\n<p>引用作为函数重载的条件</p>\n<figure class=\"highlight c\"><figcaption><span>函数注意事项</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;func(int &amp;a) 调用&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> &amp;a)</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;func(const int &amp;a) 调用&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// int &amp;a = 10; 这句话是错误的，因为引用必须引用合法的内存空间，所以这句话是错误的</span></span><br><span class=\"line\">\t<span class=\"comment\">// 那么我们想要调用上面这两个函数，方法如下：</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> &amp;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\tfunc(a);</span><br><span class=\"line\">\tfunc(<span class=\"number\">10</span>); <span class=\"comment\">// const int &amp;a = 10;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>函数重载碰到函数的默认参数</p>\n</li>\n</ol>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/",
            "title": "C++ 核心编程",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"c-核心编程\"><a class=\"anchor\" href=\"#c-核心编程\">#</a> C++ 核心编程</h1>\n<h2 id=\"内存分区模型\"><a class=\"anchor\" href=\"#内存分区模型\">#</a> 内存分区模型</h2>\n<p>C++ 程序在执行时，将内存大致分为四个区：</p>\n<ul>\n<li>代码区：存放函数体的二进制代码，由操作系统进行管理</li>\n<li>全局区：存放全局变量、静态变量以及常量，常量只包含字符串常量以及 const 修饰的全局变量</li>\n<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>\n<li>堆区：由程序员分配和释放，若没有手动释放，在程序结束后由操作系统回收</li>\n</ul>\n<h2 id=\"引用\"><a class=\"anchor\" href=\"#引用\">#</a> 引用</h2>\n<p><strong>引用的作用</strong>：给变量起别名</p>\n<p>语法：数据类型 &amp; 别名 = 原名</p>\n<figure class=\"highlight c\"><figcaption><span>引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>\n<p>引用需要的注意事项：</p>\n<ol>\n<li>引用必须要初始化；即  <code>int &amp;b;</code>  是错误的；</li>\n<li>引用一旦初始化后，就不可以更改了。</li>\n</ol>\n<h3 id=\"引用做函数的参数\"><a class=\"anchor\" href=\"#引用做函数的参数\">#</a> 引用做函数的参数</h3>\n<p><strong>作用</strong>：函数传参时，可以利用引用技术让形参修饰实参</p>\n<figure class=\"highlight c\"><figcaption><span>引用做函数参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> &amp;a, <span class=\"type\">int</span> &amp;b)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"引用作为函数的返回参数\"><a class=\"anchor\" href=\"#引用作为函数的返回参数\">#</a> 引用作为函数的返回参数</h3>\n<ol>\n<li>\n<p>不能返回局部变量的引用</p>\n</li>\n<li>\n<p>如果函数的返回值是引用，那么这个函数的调用可以作为左值</p>\n<figure class=\"highlight c\"><figcaption><span>引用做函数的返回值</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp; <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> &amp;ref = test();</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\ttest() = <span class=\"number\">1000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; ref &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">10</span></span><br><span class=\"line\"><span class=\"comment\">1000</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"引用的本质\"><a class=\"anchor\" href=\"#引用的本质\">#</a> 引用的本质</h3>\n<p>本质：引用的本质在 C++ 内部实现是一个指针常量</p>\n<figure class=\"highlight c\"><figcaption><span>引用的本质</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">   system(<span class=\"string\">&quot;chcp 65001&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 自动转换为 int * const ref = &amp;a; 指针常量的指向不可以修改，所以引用的指向不可以更改</span></span><br><span class=\"line\">   <span class=\"type\">int</span> &amp;ref = a;</span><br><span class=\"line\">   <span class=\"comment\">// 内部发现是引用，那么会转换为 *ref = 20</span></span><br><span class=\"line\">   ref = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类和对象\"><a class=\"anchor\" href=\"#类和对象\">#</a> 类和对象</h2>\n<h3 id=\"封装\"><a class=\"anchor\" href=\"#封装\">#</a> 封装</h3>\n<p>封装是三大特性之一</p>\n<p>封装的意义：</p>\n<ul>\n<li>将属性和行为作为一个整体，表现生活中的事务</li>\n<li>将属性和行为加以权限控制</li>\n</ul>\n<p>定义一个类的方法：</p>\n<figure class=\"highlight c\"><figcaption><span>类</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 &#123;</span></span><br><span class=\"line\">访问修饰符:</span><br><span class=\"line\">\t属性...</span><br><span class=\"line\">\t方法...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"访问权限\"><a class=\"anchor\" href=\"#访问权限\">#</a> 访问权限</h4>\n<ol>\n<li>public：公共权限，类内可以访问，类外可以访问</li>\n<li>protected：保护权限，类内可以访问，类外不能访问，子类可以访问父类保护的内容</li>\n<li>private：私有权限，类内可以访问，类外不能访问</li>\n</ol>\n<blockquote>\n<p><em><strong>但是，我们可以通过类中的 public 方法来修改和得到类中私有属性的值。</strong></em></p>\n</blockquote>\n<p><strong>在 C++ 中我们通常将成员变量设置为私有</strong></p>\n<ol>\n<li>将成员变量设置为私有，可以自己控制读写权限</li>\n<li>对于写权限，我们可以检测数据的有效性</li>\n</ol>\n<p>我们可以写 public 的 get 和 set 方法来实现属性的读写</p>\n<h4 id=\"class-和-struct-的区别\"><a class=\"anchor\" href=\"#class-和-struct-的区别\">#</a> class 和 struct 的区别</h4>\n<p>在 C++ 中 struct 和 class 的唯一区别就是在默认的访问权限不同</p>\n<ul>\n<li>struct 的默认访问权限是 public</li>\n<li>class 的默认访问权限是 private</li>\n</ul>\n<h3 id=\"对象特性\"><a class=\"anchor\" href=\"#对象特性\">#</a> 对象特性</h3>\n<h4 id=\"构造函数和析构函数\"><a class=\"anchor\" href=\"#构造函数和析构函数\">#</a> 构造函数和析构函数</h4>\n<p>在 C++ 中使用了构造函数和析构函数被编译器自动调用，完成对象的初始化和清理工作</p>\n<p>我们可以不提供构造和析构函数，编译器会提供，<strong>但是</strong>，编译器提供的构造函数和析构函数是空函数</p>\n<p><strong>构造函数</strong>： <code>类型()&#123;&#125;</code></p>\n<ol>\n<li>构造函数没有返回值</li>\n<li>函数名和类名相同</li>\n<li>构造函数可以有参数，因此可以重载</li>\n<li>程序在创建对象时会自动调用构造函数，无需手动调用，且只会调用一次</li>\n</ol>\n<p><strong>析构函数</strong>： <code>~类名()&#123;&#125;</code></p>\n<ol>\n<li>析构函数也没有返回值</li>\n<li>函数名和类名相同，在函数名前加上～</li>\n<li>析构函数不能有参数，因此不能发生函数重载</li>\n<li>程序在对象销毁前会自动调用析构函数，无需手动调用，且只调用一次</li>\n</ol>\n<p><strong>构造函数的分类：</strong></p>\n<ul>\n<li>按参数分：有参构造和无参构造</li>\n<li>按类型分：普通构造和拷贝构造</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造格式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person() &#123; <span class=\"comment\">// 无参构造</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person(<span class=\"type\">int</span> age) &#123; <span class=\"comment\">// 有参构造</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Person(<span class=\"type\">const</span> Person &amp;p) &#123; <span class=\"comment\">// 这里必须是 const 的对象的引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数的三种调用方式：</strong></p>\n<ol>\n<li>\n<p>括号法</p>\n<ul>\n<li><strong>调用默认构造函数时，不要加小括号</strong>（编译器会认为这是一个函数的声明）</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>括号法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1; \t\t<span class=\"comment\">// 调用默认构造函数（无参构造）</span></span><br><span class=\"line\">Person <span class=\"title function_\">p2</span><span class=\"params\">(<span class=\"number\">10</span>)</span>;  <span class=\"comment\">// 调用有参构造函数</span></span><br><span class=\"line\">Person <span class=\"title function_\">p3</span><span class=\"params\">(p2)</span>;  <span class=\"comment\">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>显示法</p>\n<figure class=\"highlight c\"><figcaption><span>显示法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = Person(<span class=\"number\">10</span>);</span><br><span class=\"line\">Person p2 = Person(p1);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Person (10); 这是匿名对象，当前行执行结束后，系统会立刻回收匿名对象</li>\n<li>不要利用拷贝构造函数初始化匿名对象，因为编译器会认为  <code>Person(p1);</code>  等价于  <code>Person p1;</code></li>\n</ul>\n</li>\n<li>\n<p>隐式转换法</p>\n<figure class=\"highlight c\"><figcaption><span>隐式转换法</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = <span class=\"number\">10</span>; <span class=\"comment\">//有参</span></span><br><span class=\"line\">Person p2 = p1; <span class=\"comment\">//拷贝</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>拷贝构造函数的调用时机</strong></p>\n<ul>\n<li>\n<p>使用一个已经创建完的对象来初始化一个新的对象</p>\n</li>\n<li>\n<p>值传递的方式给函数传参数</p>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">doWork</span><span class=\"params\">(Person p)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tPerson <span class=\"title function_\">p1</span><span class=\"params\">(<span class=\"number\">10</span>)</span>;</span><br><span class=\"line\">\tdoWork(p1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当我们调用 test 函数时，会调用有参构造函数，然后调用拷贝构造函数，这就是在使用值传递的方式给函数传递参数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>以值方式返回局部对象</p>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造函数调用时机</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person <span class=\"title function_\">doWoek2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person p1;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person p = doWork2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当我们调用 test 函数时，由于 doWork2 函数返回了对象，那么会调用一次拷贝构造函数</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>构造函数的一些规则</strong></p>\n<p>默认情况下，C++ 编译器至少给一个类添加三个函数</p>\n<ol>\n<li>默认构造函数（无参，函数体为空）</li>\n<li>默认析构函数（无参，函数体为空）</li>\n<li>默认拷贝函数，对属性进行值拷贝</li>\n</ol>\n<ul>\n<li>如果程序员提供了有参构造函数，编译器不会再提供无参的构造函数，但是会提供默认的拷贝构造函数</li>\n<li>如果程序员提供了拷贝构造函数，编译器不会再提供其他的构造函数</li>\n</ul>\n<h4 id=\"深拷贝与浅拷贝\"><a class=\"anchor\" href=\"#深拷贝与浅拷贝\">#</a> 深拷贝与浅拷贝</h4>\n<p><strong>浅拷贝</strong>：简单的赋值拷贝操作</p>\n<p>浅拷贝带来的问题就是<strong>堆区的重复释放</strong></p>\n<figure class=\"highlight c\"><figcaption><span>浅拷贝</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> p_age;</span><br><span class=\"line\">    <span class=\"type\">int</span> *p_height;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person(<span class=\"type\">int</span> age, <span class=\"type\">int</span> height) &#123;</span><br><span class=\"line\">        p_age = age;</span><br><span class=\"line\">        p_height = new <span class=\"type\">int</span>(height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Person() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 析构代码，将堆区开辟的数据进行释放</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p_height != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            delete p_height;</span><br><span class=\"line\">            p_height = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Person <span class=\"title function_\">p1</span><span class=\"params\">(<span class=\"number\">19</span>, <span class=\"number\">185</span>)</span>;</span><br><span class=\"line\">    Person <span class=\"title function_\">p2</span><span class=\"params\">(p1)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"/assets/C++/C++_1.png\" alt=\"\"></p>\n<p>为了解决上面出现的问题，我们需要使用深拷贝的方法进行解决。</p>\n<p><strong>深拷贝</strong>：在堆区重新申请空间，进行拷贝操作</p>\n<p>我们使用了深拷贝后，p1 和 p2 指向的是不同的堆区，但是存放的数据是一样的，这样就不会造成堆区内存重复释放的问题了。</p>\n<p>所以我们自己实现一个拷贝构造函数</p>\n<figure class=\"highlight c\"><figcaption><span>拷贝构造函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person(<span class=\"type\">const</span> Person &amp;p) &#123;</span><br><span class=\"line\">    p_age = p.p_age;</span><br><span class=\"line\">    p_height = new <span class=\"type\">int</span>(*p.p_height);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因此，如果有属性在堆区开辟，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。</p>\n</blockquote>\n<h4 id=\"初始化列表感觉不实用\"><a class=\"anchor\" href=\"#初始化列表感觉不实用\">#</a> 初始化列表（感觉不实用）</h4>\n<p>C++ 提供了初始化列表的语法，用来初始化属性</p>\n<p><code>构造函数(): 属性1(值1), 属性2(值2)...&#123;&#125;</code></p>\n<h4 id=\"类对象作为类成员\"><a class=\"anchor\" href=\"#类对象作为类成员\">#</a> 类对象作为类成员</h4>\n<figure class=\"highlight c++\"><figcaption><span>类对象</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    A a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当创建 B 对象时，构造和析构函数先调用谁的？</p>\n<ul>\n<li>先调用 A 的构造函数再调用 B 的构造函数</li>\n<li>析构函数的调用顺序和构造函数的调用顺序相反</li>\n</ul>\n<h4 id=\"静态成员\"><a class=\"anchor\" href=\"#静态成员\">#</a> 静态成员</h4>\n<p>静态成员就是在成员变量和成员方法前加上 static 关键字</p>\n<ul>\n<li>静态成员变量\n<ul>\n<li>所有对象公用一份数据，即静态成员变量不属于某一个具体的对象</li>\n<li>在编译阶段分配内存</li>\n<li>类内声明，类外初始化</li>\n<li>静态成员变量也是有访问权限的</li>\n</ul>\n</li>\n<li>静态成员方法\n<ul>\n<li>所有对象共享同一个函数</li>\n<li>静态成员函数只能访问静态成员变量</li>\n<li>静态成员函数也是有访问权限的</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>静态成员变量</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 什么是类内声明，类外初始化</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> a;  <span class=\"comment\">// 类内声明</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类外初始化，不需要 static 关键字，但是需要确定是 Person 类的静态变量，不加 Person:: 的话，就是全局变量了。</span></span><br><span class=\"line\"><span class=\"type\">int</span> Person::a = <span class=\"number\">100</span>; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>由于静态成员变量不属于某一个具体的对象，因此，有两种访问静态成员变量的机会：</p>\n<ol>\n<li>通过具体的对象访问</li>\n<li>通过类名来访问： <code>Person::a</code></li>\n</ol>\n<h4 id=\"c-对象模型和-this-指针\"><a class=\"anchor\" href=\"#c-对象模型和-this-指针\">#</a> C++ 对象模型和 this 指针</h4>\n<h5 id=\"成员变量和成员函数分开存储\"><a class=\"anchor\" href=\"#成员变量和成员函数分开存储\">#</a> 成员变量和成员函数分开存储</h5>\n<ul>\n<li>非静态成员变量属于一个类的对象上</li>\n<li>静态成员变量，静态、非静态成员函数不属于一个类的对象上</li>\n</ul>\n<h5 id=\"this-指针\"><a class=\"anchor\" href=\"#this-指针\">#</a> this 指针</h5>\n<p>我们知道，成员变量和成员函数是分开存储的，每一个非静态成员函数只会有一个函数实例，即多个对象会公用同一个代码块，那么，我们为了区分是那个对象调用了此非静态成员函数，就出现了 this 指针。</p>\n<p><strong>this 指针的本质是指针常量</strong></p>\n<p><strong>this 指针指向被调用的成员函数所属的对象</strong></p>\n<p>this 指针的用途：</p>\n<ol>\n<li>当形参和成员变量同名时，可以通过 this 指针来区分</li>\n<li>在类的非静态成员函数中返回对象本身，可以使用  <code>return *this</code> （因为 this 指针指向的是对象本身）</li>\n</ol>\n<blockquote>\n<p><strong>成员函数返回值和返回对象的引用的区别：</strong></p>\n<p>在 Person 类有下面这样一个成员函数：</p>\n<figure class=\"highlight c++\"><figcaption><span>返回对象引用</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Person <span class=\"title\">getPerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Person &amp; <span class=\"title\">getPerson</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面两个函数中的返回值不同，有什么区别呢？</p>\n<p>当我们返回的是 Person ，那么我们得到的是该对象经过拷贝得到的一个新的对象，而不是对象本身，如果我们向对对象本身进行操作，就不能返回 Person 而是返回引用。</p>\n<p><strong>链式编程思想</strong></p>\n</blockquote>\n<h5 id=\"空指针访问成员函数\"><a class=\"anchor\" href=\"#空指针访问成员函数\">#</a> 空指针访问成员函数</h5>\n<figure class=\"highlight c++\"><figcaption><span>空指针访问成员</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getClassName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Person&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 我们需要加上下面的代码</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        cout &lt;&lt; age &lt;&lt; endl; <span class=\"comment\">// age 相当于 this-&gt;age</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Person p = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.<span class=\"built_in\">getClassName</span>(); <span class=\"comment\">// 不会报错</span></span><br><span class=\"line\">    p.<span class=\"built_in\">getAge</span>();       <span class=\"comment\">// 会报错，因为此时 this 指针指向的是 NULL，不能访问 age</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"const-修饰成员函数\"><a class=\"anchor\" href=\"#const-修饰成员函数\">#</a> const 修饰成员函数</h5>\n<p>常函数：</p>\n<ul>\n<li>成员函数后面加上 const 我们称之为常函数</li>\n<li>常函数内不能修改成员变量</li>\n<li>成员变量声明时加上 mutable 关键字之后，在常函数中依然可以修改</li>\n</ul>\n<figure class=\"highlight c++\"><figcaption><span>常函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> age;              <span class=\"comment\">// 在常对象中这个值也不能更改</span></span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> <span class=\"type\">int</span> b;        <span class=\"comment\">// 在常对象中，这个值也可以更改</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"comment\">// 这就是一个常函数</span></span><br><span class=\"line\"> \t\t<span class=\"keyword\">this</span>-&gt;age = <span class=\"number\">10</span>;   <span class=\"comment\">// 这是不允许的，因为加了 const，相当于 const Person * const this;</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;b = <span class=\"number\">10</span>;     <span class=\"comment\">// 这是允许的</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常对象：</p>\n<ul>\n<li>声明对象前加上 const  称该对象为常对象  <code>const Person p</code></li>\n<li>常对象只能调用常函数</li>\n</ul>\n<h4 id=\"友元-friend\"><a class=\"anchor\" href=\"#友元-friend\">#</a> 友元 friend</h4>\n<p>在程序中，有些私有属性，想让类外的一些特殊的函数或者类进行访问，就需要使用到友元技术</p>\n<p>友元的三种实现</p>\n<ul>\n<li>\n<p>全局函数做友元</p>\n<figure class=\"highlight c++\"><figcaption><span>全局函数友元</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">getA</span><span class=\"params\">(Person &amp;p)</span></span>;  <span class=\"comment\">// 加上这段代码，这个全局函数就可以访问到该类的私有变量了</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getA</span><span class=\"params\">(Person &amp;p)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; p.a &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>类做友元  <code>friend class 类名;</code></p>\n</li>\n<li>\n<p>成员函数做友元  <code>friend 函数返回值 类名::方法名();</code></p>\n</li>\n</ul>\n<h4 id=\"运算符重载\"><a class=\"anchor\" href=\"#运算符重载\">#</a> 运算符重载</h4>\n<p>什么是运算符的重载？</p>\n<p>对已有的运算符进行重新定义，赋予另外一种功能</p>\n<p><strong>运算符重载也可以发生函数重载</strong></p>\n<h5 id=\"加号运算符重载\"><a class=\"anchor\" href=\"#加号运算符重载\">#</a> 加号运算符重载</h5>\n<p>成员方法实现</p>\n<figure class=\"highlight c++\"><figcaption><span>加号运算符重载</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;a = a;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;b = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 成员方法实现运算符重载</span></span><br><span class=\"line\">    Person <span class=\"keyword\">operator</span>+(Person &amp;p) &#123;</span><br><span class=\"line\">        Person temp;</span><br><span class=\"line\">        temp.a = <span class=\"keyword\">this</span>-&gt;a + p.a;</span><br><span class=\"line\">        temp.b = <span class=\"keyword\">this</span>-&gt;b + p.b;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Person p3 = p1 + p2;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; p3.a &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; p3.b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>全局函数实现的方法很简单，就是写一个  <code>operator+</code>  全局函数就行了，和上面的成员方法会略有区别（形参不同）。</p>\n<h5 id=\"左移运算符重载\"><a class=\"anchor\" href=\"#左移运算符重载\">#</a> 左移运算符重载</h5>\n<p>只能利用全局函数重载左移运算符</p>\n<p>重载左移运算符的作用和 Java 中的 toString 类似</p>\n<figure class=\"highlight c++\"><figcaption><span>左移运算符重载</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;cout, Person p);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;a = a;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;b = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;cout, Person p) &#123;</span><br><span class=\"line\">    cout &lt;&lt; p.a &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; p.b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cout;  <span class=\"comment\">// 为了能实现链式调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;chcp 65001&quot;</span>);</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"\"><a class=\"anchor\" href=\"#\">#</a> </h5>\n<h5 id=\"赋值运算符重载\"><a class=\"anchor\" href=\"#赋值运算符重载\">#</a> 赋值运算符重载</h5>\n<figure class=\"highlight c++\"><figcaption><span>赋值运算符重载</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Person &amp;<span class=\"keyword\">operator</span>=(Person &amp;p) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断原来的堆区是否释放干净</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (age != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> age;</span><br><span class=\"line\">            age = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        age = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(*p.age);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"type\">int</span> age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> *age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;chcp 65001&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">18</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">p3</span><span class=\"params\">(<span class=\"number\">26</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    p3 = p2 = p1;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; *p1.age &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *p2.age &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *p3.age &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过重载赋值运算符，我们通过另一种方式实现了深拷贝。</p>\n<h5 id=\"关系运算符重载\"><a class=\"anchor\" href=\"#关系运算符重载\">#</a> 关系运算符重载</h5>\n<figure class=\"highlight c++\"><figcaption><span>关系运算符重载</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"type\">int</span> age, string name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"keyword\">operator</span>==(Person &amp;p) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;age == p.age &amp;&amp; <span class=\"keyword\">this</span>-&gt;name == p.name)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>相当于 Java 中重写 equals 函数</p>\n<h3 id=\"继承\"><a class=\"anchor\" href=\"#继承\">#</a> 继承</h3>\n<p>语法： <code>class 子类 : 继承方式 父类</code></p>\n<p>继承方式：</p>\n<ul>\n<li>public 继承方式\n<ul>\n<li>基类中所有 public 成员在派生类中为 public 属性；</li>\n<li>基类中所有 protected 成员在派生类中为 protected 属性；</li>\n<li>基类中所有 private 成员在派生类中不能使用。</li>\n</ul>\n</li>\n<li>protected 继承方式\n<ul>\n<li>基类中的所有 public 成员在派生类中为 protected 属性；、</li>\n<li>基类中的所有 protected 成员在派生类中为 protected 属性；</li>\n<li>基类中的所有 private 成员在派生类中不能使用。</li>\n</ul>\n</li>\n<li>private 继承方式\n<ul>\n<li>基类中的所有 public 成员在派生类中均为 private 属性；</li>\n<li>基类中的所有 protected 成员在派生类中均为 private 属性；</li>\n<li>基类中的所有 private 成员在派生类中不能使用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"继承中构造和析构的调用顺序\"><a class=\"anchor\" href=\"#继承中构造和析构的调用顺序\">#</a> 继承中构造和析构的调用顺序</h4>\n<blockquote>\n<p>子类继承父类后，当创建子类对象，也会调用父类的构造函数。</p>\n</blockquote>\n<p>我们创建子类的对象发现：先调用父类的构造函数，再调用子类的构造函数，析构函数的调用顺序和构造函数相反。</p>\n<h4 id=\"继承同名成员处理方式\"><a class=\"anchor\" href=\"#继承同名成员处理方式\">#</a> 继承同名成员处理方式</h4>\n<ul>\n<li>访问子类同名成员：直接访问即可</li>\n<li>访问父类同名成员：需要加作用域  <code>s.Base::a</code>  即可访问到父类的同名属性，方法也是同样的方式</li>\n</ul>\n<blockquote>\n<p>静态成员和非静态成员的处理方式一致</p>\n</blockquote>\n<blockquote>\n<p>如果子类出现了和父类同名的成员，那么父类的成员将会被子类覆盖，如果想访问父类的成员，就必须加作用域。</p>\n</blockquote>\n<h4 id=\"多继承\"><a class=\"anchor\" href=\"#多继承\">#</a> 多继承</h4>\n<figure class=\"highlight c++\"><figcaption><span>代码样例</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : 继承方式 A, 继承方式 B, 继承方式 C &#123;</span><br><span class=\"line\">\t······</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"菱形继承和虚继承\"><a class=\"anchor\" href=\"#菱形继承和虚继承\">#</a> 菱形继承和虚继承</h5>\n<h4 id=\"使用-final-禁止继承\"><a class=\"anchor\" href=\"#使用-final-禁止继承\">#</a> 使用 final 禁止继承</h4>\n<h3 id=\"多态\"><a class=\"anchor\" href=\"#多态\">#</a> 多态</h3>\n<h4 id=\"基本概念\"><a class=\"anchor\" href=\"#基本概念\">#</a> 基本概念</h4>\n<p>多态分为两类：</p>\n<ul>\n<li>静态多态：<strong>函数重载和运算符重载</strong>属于静态多态</li>\n<li>动态多态：派生类和虚函数实现运行时多态</li>\n</ul>\n<p>静态多态和动态多态的区别：</p>\n<ul>\n<li>\n<p>静态多态的函数地址早绑定 —— 编译阶段确定函数地址</p>\n</li>\n<li>\n<p>动态多态的函数地址晚绑定 —— 运行阶段确定函数地址</p>\n</li>\n</ul>\n<p>案例：</p>\n<figure class=\"highlight c++\"><figcaption><span>案例</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;动物再说话\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 虚函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;动物再说话\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Speak</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;猫在说话\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doSpeak</span><span class=\"params\">(Animal &amp; animal)</span> </span>&#123;</span><br><span class=\"line\">    animal.<span class=\"built_in\">Speak</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;chcp 65001&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Cat cat;</span><br><span class=\"line\">    <span class=\"built_in\">doSpeak</span>(cat);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们写成上面的代码的时候，输出的是动物在说话，原因是函数的地址在编译阶段就绑定了，我们为了实现动态多态，需要在基类的函数前加上  <code>virtual</code>  关键字</p>\n<p>因此，动态多态需要满足的两个条件：</p>\n<ol>\n<li>存在继承关系</li>\n<li>子类重写父类的虚函数</li>\n</ol>\n<blockquote>\n<p>重写：函数的返回值类型、函数名称、函数的参数列表完全相同</p>\n</blockquote>\n<p>什么时间会使用动态多态：父类的<strong>指针或者引用</strong>指向子类的对象</p>\n<h5 id=\"多态原理分析\"><a class=\"anchor\" href=\"#多态原理分析\">#</a> 多态原理分析</h5>\n<blockquote>\n<p>非静态的成员函数不属于类</p>\n</blockquote>\n<p>在上面的 Animal 类中，如果 speak 函数没有加 virtual 关键字，则  <code>sizeof(Animal) = 1</code> ， 如果加上 virtual 关键字，那么  <code>sizeof(Animal) = 4 </code> 。也就是说，加上 virtual 关键字，类的结构发生了改变，这四个字节实际上是一个指针。</p>\n<p>使用开发者工具，我们可以看到 Animal 类的结构：</p>\n<figure class=\"highlight c++\"><figcaption><span>Animal</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> Animal       <span class=\"title\">size</span><span class=\"params\">(<span class=\"number\">4</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t+---</span></span><br><span class=\"line\"><span class=\"function\">0       | <span class=\"params\">(vfptr)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t+---</span></span><br><span class=\"line\"><span class=\"function\">Animal::$vftable@:</span></span><br><span class=\"line\"><span class=\"function\">\t\t|&amp;Animal_meta</span></span><br><span class=\"line\"><span class=\"function\">\t\t|<span class=\"number\">0</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"number\">0</span>\t\t|&amp;Animal::speak</span></span><br></pre></td></tr></table></figure>\n<p>上面的 vfptr 是虚函数表指针，指向下面的<strong>虚函数表</strong></p>\n<h4 id=\"纯虚函数和抽象类\"><a class=\"anchor\" href=\"#纯虚函数和抽象类\">#</a> 纯虚函数和抽象类</h4>\n<p>在多态中，通常父类中虚函数的实现是毫无意义的，基本都是调用子类重写的内容，因此可以将虚函数改为纯虚函数</p>\n<p>语法： <code>virtual 返回值类型 函数名(参数列表) = 0;</code></p>\n<p>当类中有纯虚函数，这个类也被称为抽象类</p>\n<p>抽象类的特点：</p>\n<ol>\n<li>无法实例化对象</li>\n<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>\n</ol>\n<h4 id=\"虚析构和纯虚析构\"><a class=\"anchor\" href=\"#虚析构和纯虚析构\">#</a> 虚析构和纯虚析构</h4>\n<p>多态使用时，如果子类中有属性开辟到堆区，那么父类的指针在释放时无法调用到子类的析构代码，为了解决这一问题，我们需要将父类的析构函数改为<strong>虚析构或纯虚析构</strong></p>\n<p>虚析构和纯虚析构的共性：</p>\n<ul>\n<li>可以解决父类指针释放子类对象</li>\n<li>都需要有具体的函数实现（纯虚析构函数在类外通过加类的作用域进行实现  <code>类名::~类名() &#123;&#125;</code></li>\n</ul>\n<p>虚析构和纯虚析构的区别：</p>\n<ul>\n<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>\n</ul>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/%E6%A8%A1%E6%9D%BF/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/%E6%A8%A1%E6%9D%BF/",
            "title": "模板",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/%E7%BB%93%E6%9E%84%E4%BD%93/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/%E7%BB%93%E6%9E%84%E4%BD%93/",
            "title": "结构体",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"结构类型-宏\"><a class=\"anchor\" href=\"#结构类型-宏\">#</a> 结构类型、宏</h1>\n<h3 id=\"结构类型\"><a class=\"anchor\" href=\"#结构类型\">#</a> 结构类型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> month;</span><br><span class=\"line\">    <span class=\"type\">int</span> day;</span><br><span class=\"line\">    <span class=\"type\">int</span> year;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义变量（还有其他方法）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span>;</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span> =</span> &#123;.month = <span class=\"number\">7</span>, .year = <span class=\"number\">2023</span>&#125;;</span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> <span class=\"title\">today</span> =</span> &#123;<span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">2023</span>&#125;; </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 访问成员</span></span><br><span class=\"line\"> today.month</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 结构指针</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">date</span> *<span class=\"title\">pDate</span> =</span> &amp;today;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 指针所指的结构变量的成员</span></span><br><span class=\"line\">(*pDate).month = <span class=\"number\">12</span>;</span><br><span class=\"line\">pDate-&gt;month = <span class=\"number\">12</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义数据类型\"><a class=\"anchor\" href=\"#自定义数据类型\">#</a> 自定义数据类型</h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ADate</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> month;</span><br><span class=\"line\">    <span class=\"type\">int</span> day;</span><br><span class=\"line\">    <span class=\"type\">int</span> year;</span><br><span class=\"line\">&#125; Date;</span><br></pre></td></tr></table></figure>\n<h3 id=\"宏\"><a class=\"anchor\" href=\"#宏\">#</a> 宏</h3>\n<h4 id=\"编译预处理指令\"><a class=\"anchor\" href=\"#编译预处理指令\">#</a> 编译预处理指令</h4>\n<ul>\n<li>\n<p>#开头的是编译预处理指令</p>\n</li>\n<li>\n<p>它们不是 C 语言的成分，但是 C 语言程序离不开它们</p>\n</li>\n<li>\n<p>#define 用来定义一个宏</p>\n<figure class=\"highlight c\"><figcaption><span>宏</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结尾没有分号，因为不是 C 的语句</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PI 3.14159</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果一个宏的值中有其他宏的名字，也是会被替换的</p>\n</li>\n<li>\n<p>如果一个宏的值超过一行，最后一行之前的行末需要加 \\</p>\n</li>\n<li>\n<p>宏的值后面出现的注释不会被当作宏的一部分</p>\n</li>\n<li>\n<p>宏可以带参数（像函数一样）</p>\n</li>\n</ul>\n<hr>\n<p>C 语言包含哪些数据类型？</p>\n<ol>\n<li>整数\n<ol>\n<li>char：1 字节</li>\n<li>short：2 字节</li>\n<li>int：取决于编译器，通常的意义是 “1 个字”</li>\n<li>long：取决于编译器</li>\n<li>long long：8 字节</li>\n</ol>\n</li>\n<li>浮点数\n<ol>\n<li>float</li>\n<li>double</li>\n<li>long double</li>\n</ol>\n</li>\n<li>逻辑\n<ol>\n<li>bool</li>\n</ol>\n</li>\n<li>指针</li>\n<li>自定义类型</li>\n</ol>\n<blockquote>\n<p>C 语言提供了 sizeof（静态运算符） 来给出某个类型或者某个变量在内存中所占据的字节数</p>\n<p>整数在计算机中以补码的形式存在。比如 char 类型的变量 c = 255， 那么我们以整数的方式输出，得到的是 -1，如果想让该字符就是 255，那么可以加上 unsigned 关键字</p>\n</blockquote>\n<ul>\n<li>在使用和定义这个函数的地方都应该 #include 这个头文件（文本插入）</li>\n</ul>\n<blockquote>\n<p><strong>声明和定义</strong></p>\n<p>int i; 变量的定义</p>\n<p>extern int i; 变量的声明（在头文件中）</p>\n<ul>\n<li>声明是不产生代码的东西\n<ul>\n<li>函数原型</li>\n<li>变量声明</li>\n<li>结构声明</li>\n<li>宏声明</li>\n<li>枚举声明</li>\n<li>类型声明</li>\n<li>inline 函数</li>\n</ul>\n</li>\n<li>定义是产生代码的东西</li>\n</ul>\n</blockquote>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/13/robot/C++/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/",
            "url": "https://lktwh.github.io/2023/10/13/robot/C++/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/",
            "title": "数组与指针",
            "date_published": "2023-10-13T14:26:00.000Z",
            "content_html": "<h1 id=\"数组和指针\"><a class=\"anchor\" href=\"#数组和指针\">#</a> 数组和指针</h1>\n<h2 id=\"数组\"><a class=\"anchor\" href=\"#数组\">#</a> 数组</h2>\n<figure class=\"highlight c\"><figcaption><span>数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如何得到数组的长度呢？ （sizeof）</span></span><br><span class=\"line\"><span class=\"type\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> length = <span class=\"keyword\">sizeof</span>(a) / <span class=\"keyword\">sizeof</span>(a[<span class=\"number\">0</span>]); </span><br></pre></td></tr></table></figure>\n<h3 id=\"定义数组\"><a class=\"anchor\" href=\"#定义数组\">#</a> 定义数组</h3>\n<figure class=\"highlight c\"><figcaption><span>数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C99 之前：元素的数量必须是编译时刻确定的字面量</span></span><br><span class=\"line\">type arrayName[ arraySize ]; <span class=\"comment\">//这样定义的数组未初始化</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>数组作为函数的参数时，往往需要另一个参数来传入数组的大小</p>\n</blockquote>\n<h3 id=\"二维数组\"><a class=\"anchor\" href=\"#二维数组\">#</a> 二维数组</h3>\n<p>定义</p>\n<figure class=\"highlight c\"><figcaption><span>二维数组</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrayName[row][col]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>列数是必须给出的，行数可以由编译器来数</li>\n<li>每行一个 {} ，使用逗号分隔</li>\n</ul>\n</blockquote>\n<h2 id=\"取地址运算\"><a class=\"anchor\" href=\"#取地址运算\">#</a> 取地址运算：&amp;</h2>\n<ul>\n<li>\n<p>&amp;：获取变量的地址，操作数必须是一个变量</p>\n</li>\n<li>\n<p>地址的大小是否与 int 相同取决于编译器</p>\n<figure class=\"highlight c\"><figcaption><span>取址运算符</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lu\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lu\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(&amp;a));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在 64 位架构下，得到的结果是：4   8</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"指针\"><a class=\"anchor\" href=\"#指针\">#</a> 指针</h2>\n<ul>\n<li>指针变量就是保存地址的变量\n<ul>\n<li><code>int *p = &amp;i</code></li>\n</ul>\n</li>\n<li>变量的值是内存的地址\n<ul>\n<li>普通变量的值是实际的值</li>\n<li>指针变量的值是具有实际值的变量的地址</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"作为参数的指针\"><a class=\"anchor\" href=\"#作为参数的指针\">#</a> 作为参数的指针</h4>\n<figure class=\"highlight c\"><figcaption><span>指针参数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stdio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> *p)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&amp;a=%p\\n&quot;</span>, &amp;a);</span><br><span class=\"line\">    f(&amp;a);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> *p)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; p=%p\\n&quot;</span>, p);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*p=%d\\n&quot;</span>, *p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">&amp;a=00000009087ffc3c</span></span><br><span class=\"line\"><span class=\"comment\"> p=00000009087ffc3c</span></span><br><span class=\"line\"><span class=\"comment\">*p=0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"访问那个地址上的变量\"><a class=\"anchor\" href=\"#访问那个地址上的变量\">#</a> 访问那个地址上的变量</h4>\n<ul>\n<li>\n<p>* 是一个单目运算符，用来访问指针的值所表示的地址上的变量</p>\n</li>\n<li>\n<p>可以作左值，也可以作右值</p>\n<figure class=\"highlight c\"><figcaption><span>*运算符</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> k = *p;</span><br><span class=\"line\">*p = k + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"指针应用\"><a class=\"anchor\" href=\"#指针应用\">#</a> 指针应用</h4>\n<ul>\n<li>函数返回多个值，某些值只能通过指针返回</li>\n</ul>\n<h4 id=\"指针与数组\"><a class=\"anchor\" href=\"#指针与数组\">#</a> 指针与数组</h4>\n<p>传入函数的数组成了什么？</p>\n<ul>\n<li>函数参数表中的数组实际上是指针\n<ul>\n<li>sizeof(a) == sizeof(int *)</li>\n<li>但是可以使用数组的运算符 [] 进行运算</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"数组变量是特殊的指针\"><a class=\"anchor\" href=\"#数组变量是特殊的指针\">#</a> 数组变量是特殊的指针</h5>\n<ul>\n<li>数组变量本身表达地址，因此\n<ul>\n<li>int a [10]; int *p = a; // 不需要 &amp;</li>\n<li>但是数组的单元表达的是变量 需要使用 &amp; 取地址</li>\n<li>a == &amp;a[0]</li>\n</ul>\n</li>\n<li>[] 运算符可以对数组做，也可以对指针做</li>\n<li>p[0] &lt;==&gt; a[0]</li>\n<li>* 运算符可以对指针做，也可以对数组做\n<ul>\n<li>*a &lt;==&gt; a[0]</li>\n</ul>\n</li>\n<li>数组变量是 const 指针，所以不能被赋值，即\n<ul>\n<li>int a[] &lt;==&gt; int * const a</li>\n<li>因此，int b []; b = a 是错误的</li>\n<li>但是可以写成 int *q = a;</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"指针与-const\"><a class=\"anchor\" href=\"#指针与-const\">#</a> 指针与 const</h4>\n<h5 id=\"指针是-const指针常量\"><a class=\"anchor\" href=\"#指针是-const指针常量\">#</a> 指针是 const（指针常量）</h5>\n<ul>\n<li>表示一旦得到某个变量的地址，就不能再指向其他的变量</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>指针常量</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> * <span class=\"type\">const</span> q = &amp;i; <span class=\"comment\">// q 是 const</span></span><br><span class=\"line\">*q = <span class=\"number\">22</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">q++;  <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">q = &amp;j;  <span class=\"comment\">// ERROR </span></span><br></pre></td></tr></table></figure>\n<h5 id=\"所指的是-const常量指针\"><a class=\"anchor\" href=\"#所指的是-const常量指针\">#</a> 所指的是 const（常量指针）</h5>\n<ul>\n<li>表示不能通过指针去修改那个变量（指针的指向可以修改，但是指针指向的值不能修改）</li>\n</ul>\n<figure class=\"highlight c\"><figcaption><span>常量指针</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *p = &amp;i;</span><br><span class=\"line\">*p = <span class=\"number\">26</span>; <span class=\"comment\">// ERROR</span></span><br><span class=\"line\">i = <span class=\"number\">26</span>;  <span class=\"comment\">// OK</span></span><br><span class=\"line\">p = &amp;j; <span class=\"comment\">// OK </span></span><br></pre></td></tr></table></figure>\n<h5 id=\"保护数组的值\"><a class=\"anchor\" href=\"#保护数组的值\">#</a> 保护数组的值</h5>\n<ul>\n<li>因为把数组传入函数时传递的是地址，所以函数内部可以修改数组的值</li>\n<li>为了保护数组的值不被函数破坏，可以将参数设置为 const</li>\n<li>int sum(const int a[], int length);</li>\n</ul>\n<h4 id=\"空指针与野指针\"><a class=\"anchor\" href=\"#空指针与野指针\">#</a> 空指针与野指针</h4>\n<h5 id=\"空指针\"><a class=\"anchor\" href=\"#空指针\">#</a> 空指针</h5>\n<ul>\n<li>空指针用于给指针变量进行初始化： <code>int *p = NULL</code></li>\n<li>空指针是不能进行访问的，即 <code>*p = 100</code>  是不允许的</li>\n</ul>\n<h5 id=\"野指针\"><a class=\"anchor\" href=\"#野指针\">#</a> 野指针</h5>\n<h4 id=\"指针运算\"><a class=\"anchor\" href=\"#指针运算\">#</a> 指针运算</h4>\n<p>*(p + n) &lt;==&gt; a[n]</p>\n<p>*p++  （优先级）</p>\n",
            "tags": [
                "机器人",
                "C++",
                "C++"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/os/FreeRTOS/",
            "url": "https://lktwh.github.io/2023/10/03/os/FreeRTOS/",
            "title": "FreeRTOS",
            "date_published": "2023-10-03T14:26:00.000Z",
            "content_html": "<h2 id=\"操作系统\"><a class=\"anchor\" href=\"#操作系统\">#</a> 操作系统</h2>\n<p>一个操作系统的主要功能主要有：</p>\n<ul>\n<li>任务（应用程序）的调度管理</li>\n<li>堆栈和内存管理</li>\n<li>文件管理</li>\n<li>队列管理</li>\n<li>中断和定时器管理</li>\n<li>资源管理</li>\n<li>输入输出管理</li>\n</ul>\n<h2 id=\"实时操作系统rtos\"><a class=\"anchor\" href=\"#实时操作系统rtos\">#</a> 实时操作系统（RTOS）</h2>\n<p>​\t\t是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，调度一切可利用的资源完成实时任务，并控制所有实时任务协调一致运行的操作系统。提供及时响应和高可靠性是其主要特点。</p>\n<p>​\t\t<strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2ZlYXR1cmVzLmh0bWw=\">FreeRTOS 开发者文档</span></strong></p>\n<h2 id=\"freertos-源码概述\"><a class=\"anchor\" href=\"#freertos-源码概述\">#</a> FreeRTOS 源码概述</h2>\n<h3 id=\"freertos-目录结构\"><a class=\"anchor\" href=\"#freertos-目录结构\">#</a> FreeRTOS 目录结构</h3>\n<p><img data-src=\"/assets/freertos1.png\" alt=\"\"></p>\n<h3 id=\"核心文件的作用\"><a class=\"anchor\" href=\"#核心文件的作用\">#</a> 核心文件的作用</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Source 下的文件</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">task.c</td>\n<td style=\"text-align:center\">必需， 任务操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">list.c</td>\n<td style=\"text-align:center\">必需，列表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">queue.c</td>\n<td style=\"text-align:center\">基本必需，提供队列操作、信号量 (semaphore) 操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timer.c</td>\n<td style=\"text-align:center\">可选，software timer</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">event_groups.c</td>\n<td style=\"text-align:center\">可选，提供 event group 功能</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">croutine.c</td>\n<td style=\"text-align:center\">可选，过时了</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"堆和栈\"><a class=\"anchor\" href=\"#堆和栈\">#</a> 堆和栈</h2>\n<blockquote>\n<ul>\n<li>堆，heap，就是一块空闲的内存，需要提供管理函数\n<ul>\n<li>malloc：从堆里划出一块空间给程序使用</li>\n<li>free：用完后，再把它标记为 &quot;空闲&quot; 的，可以再次使用</li>\n</ul>\n</li>\n<li>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中\n<ul>\n<li>可以从堆中分配一块空间用作栈</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>每个 FreeRTOS 任务都需要<strong>自己的栈空间</strong>（任务栈），用来保存每个任务自己的现场、自己的局部变量以及调用关系</p>\n<h2 id=\"内存管理\"><a class=\"anchor\" href=\"#内存管理\">#</a> 内存管理</h2>\n<p>内存管理就是如何如使用 FreeRTOS 中的堆。每次创建任务、队列、互斥锁、软件定时器、信号量或事件组时，RTOS 内核都需要 RAM ， RAM 可以从 RTOS API 对象创建函数内的 RTOS 堆自动动态分配。</p>\n<p>在 C 语言的库函数中，由 malloc、free 等函数，但是它们不适用在 FreeRTOS 中：</p>\n<ul>\n<li>不适合用在资源紧缺的嵌入式系统中</li>\n<li>这些函数的实现过于复杂、占据的代码空间太大</li>\n<li>并非线程安全的 (thread- safe)</li>\n<li>运行有不确定性：每次调用这些函数时花费的时间可能都不相同</li>\n<li>内存碎片化</li>\n<li>使用不同的编译器时，需要进行复杂的配置</li>\n<li>有时候难以调试</li>\n</ul>\n<p>因此，FreeRTOS 提供了几套复杂性和功能各不行同的堆的管理方案，我们可以根据自己的需求，选择合适的方案。</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMQ==\">heap_1</span> —— 最简单，不允许释放内存。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMg==\">heap_2</span>—— 允许释放内存，但不会合并相邻的空闲块。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfMw==\">heap_3</span> —— 简单包装了标准 malloc () 和 free ()，以保证线程安全。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfNA==\">heap_4</span> —— 合并相邻的空闲块以避免碎片化。 包含绝对地址放置选项。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZXJ0b3Mub3JnL3poLWNuLWNtbi1zL2EwMDExMS5odG1sI2hlYXBfNQ==\">heap_5 </span>—— 如同 heap_4，能够跨越多个<strong>不相邻内存区域的堆</strong>。比如我不仅可以使用片上的 RAM ，还可以使用片外的 RAM。</li>\n</ul>\n<p>在这些方案中 heap_4 较为常用</p>\n<h3 id=\"heap_4\"><a class=\"anchor\" href=\"#heap_4\">#</a> heap_4</h3>\n<p>Heap_4 会把相邻空闲内存合并为一个大的空闲内存，可以较少内存的碎片化问题。适用于这种场景：频繁地分配、释放不同大小的内存。</p>\n<p>内存堆仍然是一个大数组，定义为：</p>\n<figure class=\"highlight c\"><figcaption><span>堆定义</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br></pre></td></tr></table></figure>\n<p>可用堆空间的总量通过  <code>configTOTAL_HEAP_SIZE</code>  设置（位于  <code>FreeRTOSConfig.h</code>  中）</p>\n<p>heap_4 的功能：</p>\n<ul>\n<li>即使应用程序重复删除任务、队列、 信号量、互斥锁等，仍然可用。</li>\n<li>与 heap_2 实现相比，导致堆空间严重碎片化成多个小块的可能性更小 （即使正在分配和释放的内存是随机大小） 。</li>\n<li>不具有确定性，但比大多数标准 C 库 malloc 实现更有效。</li>\n</ul>\n<h3 id=\"使用的-api\"><a class=\"anchor\" href=\"#使用的-api\">#</a> 使用的 API</h3>\n<figure class=\"highlight c\"><figcaption><span>堆相关 API</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> *<span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xSize )</span>   <span class=\"comment\">//内存申请函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vPortFree</span><span class=\"params\">( <span class=\"type\">void</span> *pv )</span>  <span class=\"comment\">//内存释放函数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vPortInitialiseBlocks</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//初始化内存堆函数</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//获取当前未分配的内存堆大小</span></span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetMinimumEverFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>  <span class=\"comment\">//获取未分配的内存堆历史最小值</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"任务管理\"><a class=\"anchor\" href=\"#任务管理\">#</a> 任务管理</h2>\n<p>在使用 FeeRTOS 时，我们在 application 中创建多个任务。</p>\n<h3 id=\"什么是任务\"><a class=\"anchor\" href=\"#什么是任务\">#</a> 什么是任务</h3>\n<p>在 FreeRTOS 中，任务就是一个函数，原型如下，通常包含一个永远不会退出的循环体</p>\n<figure class=\"highlight c\"><figcaption><span>任务函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */</span></span><br><span class=\"line\">\t<span class=\"type\">int32_t</span> lVariableExample = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 任务函数通常实现为一个无限循环 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( ;; )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 任务的代码 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 如果程序从循环中退出，一定要使用vTaskDelete删除自己</span></span><br><span class=\"line\"><span class=\"comment\">     * NULL表示删除的是自己</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">\tvTaskDelete( <span class=\"literal\">NULL</span> );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 程序不会执行到这里, 如果执行到这里就出错了 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的点：</p>\n<ul>\n<li>这个函数不能有返回值</li>\n<li>同一个函数，可以用来创建多个任务。即多个任务可以运行同一个函数</li>\n<li>如果不需要这个任务，必须使用语句显示地删除这个任务</li>\n<li>每一个任务都有自己的栈以及优先级</li>\n<li>在每个函数内部，尽量使用局部变量\n<ul>\n<li>每个任务有自己的栈</li>\n<li>每个任务运行这个函数时\n<ul>\n<li>任务 A 的局部变量放在任务 A 的栈中，任务 B 的局部变量放在任务 B 的栈中</li>\n<li>不同任务的局部变量，都有自己的副本</li>\n</ul>\n</li>\n<li>如果函数使用全局变量、静态变量的话\n<ul>\n<li>多个任务使用的是同一个副本</li>\n<li>需要防止冲突</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"任务创建\"><a class=\"anchor\" href=\"#任务创建\">#</a> 任务创建</h3>\n<p>函数如下：</p>\n<figure class=\"highlight c\"><figcaption><span>任务创建函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreate</span><span class=\"params\">( TaskFunction_t pxTaskCode, <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName, <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters, <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">                        UBaseType_t uxPriority,    <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">                        TaskHandle_t * <span class=\"type\">const</span> pxCreatedTask )</span>; <span class=\"comment\">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ol>\n<li>pvTaskCode ：函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 vTaskDelete</li>\n<li>pcName ：任务的名称，仅用于调试目的，长度为 configMAX_TASK_NAME_LEN</li>\n<li>usStackDepth ：每个任务都有自己的栈，该参数指定了栈的大小，单位为 word。例如传入的是 100，表示栈的大小为 400 字节。确定栈的大小最精确的方法是使用反汇编</li>\n<li>pvParameters ：调用的任务函数时使用的参数</li>\n<li>uxPriority ：任务的优先级范围 0 ~ configMAX_PROORITIES - 1。数值越小，优先级越低。如果传入的值过大，xTaskCreate 会将其调整为 configMAX_PRIORITIES – 1</li>\n<li>pxCreatedTask ：用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要堆该任务进行操作，例如修改优先级，则需要使用该句柄。如果不需要该句柄，则传入 NULL</li>\n</ol>\n<h3 id=\"任务删除\"><a class=\"anchor\" href=\"#任务删除\">#</a> 任务删除</h3>\n<p>任务删除函数：</p>\n<figure class=\"highlight c\"><figcaption><span>任务删除函数</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelete</span><span class=\"params\">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>pvTaskCode ：任务句柄，使用 xTaskCreate 创建任务时可以得到一个句柄。也可以传入 NULL，表示删除自己。</li>\n</ul>\n<h3 id=\"任务优先级\"><a class=\"anchor\" href=\"#任务优先级\">#</a> 任务优先级</h3>\n",
            "tags": [
                "操作系统",
                "FreeRTOS"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/datastructure/stack/",
            "url": "https://lktwh.github.io/2023/10/03/datastructure/stack/",
            "title": "栈",
            "date_published": "2023-10-03T12:14:00.000Z",
            "content_html": "<p>这里开始正文。。。。。</p>\n<ul>\n<li>[算法，算法 - 新手]  表示在算法下的子目录，算法 - 新手下</li>\n<li>Java \t\t\t\t表示在 java 分类下</li>\n</ul>\n",
            "tags": [
                "数据结构",
                "栈"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/stm32/F103/",
            "url": "https://lktwh.github.io/2023/10/03/stm32/F103/",
            "title": "STM32F103",
            "date_published": "2023-10-03T12:14:00.000Z",
            "content_html": "",
            "tags": [
                "单片机",
                "STM32"
            ]
        },
        {
            "id": "https://lktwh.github.io/2023/10/03/hello-world/",
            "url": "https://lktwh.github.io/2023/10/03/hello-world/",
            "title": "Hello World",
            "date_published": "2023-10-03T10:52:37.910Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}